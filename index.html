<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Urban Traffic Analyzer</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
<style>
  *{box-sizing:border-box}body{margin:0;font-family:system-ui,Segoe UI,Arial;height:100vh;overflow:hidden}
  #map{height:100vh}
  .panel{position:absolute;top:16px;right:16px;background:#fff;padding:16px;border-radius:8px;box-shadow:0 2px 12px rgba(0,0,0,.15);z-index:1000;width:300px;max-height:90vh;overflow:auto}
  .panel h3{margin:0 0 8px}
  .hint{font-size:12px;background:#E3F2FD;color:#1976D2;padding:8px;border-radius:4px;margin-bottom:8px}
  .btn,select{width:100%;padding:10px;margin:6px 0;border:none;border-radius:6px;background:#4CAF50;color:#fff;cursor:pointer}
  .btn:disabled{background:#ccc;cursor:not-allowed}
  .btn.secondary{background:#000}.btn.warn{background:#FF9800}.btn.danger{background:#f44336}
  .status{background:#f7f7f7;padding:8px;border-radius:4px;font-size:12px;margin-top:8px}
  .legend{margin-top:10px;background:#f9f9f9;padding:8px;border-radius:4px;font-size:12px}
  .legend-item{display:flex;align-items:center;margin:4px 0}
  .legend-color{width:30px;height:3px;margin-right:8px}
  .stats{margin-top:8px;background:#E8F5E9;padding:8px;border-radius:4px;font-size:12px}
  .street-popup{font-size:12px}
  /* Animations */
  .closed{animation:flash 1.2s ease-in-out infinite}
  @keyframes flash{0%,100%{opacity:.55}50%{opacity:1}}
  .altPulse{animation:pulse 1.8s ease-in-out infinite}
  @keyframes pulse{0%,100%{opacity:.6}50%{opacity:1}}
</style>
</head>
<body>
<div id="map"></div>

<div class="panel">
  <h3>üö¶ Traffic Analyzer</h3>
  <div class="hint">Draw a polygon or use current map view, then click ‚ÄúLoad Street Network‚Äù.</div>

  <button id="btnLoad" class="btn">Load Street Network</button>

  <label style="font-size:12px;color:#555;margin-top:6px">Traffic Period</label>
  <select id="selPeriod" disabled>
    <option value="">Select period‚Ä¶</option>
    <option value="morning">Morning Rush (7-9)</option>
    <option value="evening">Evening Rush (5-7)</option>
    <option value="offpeak">Off-Peak (2-4)</option>
  </select>

  <button id="btnImportance" class="btn" style="background:#9C27B0" disabled>Calculate Importance</button>

  <label style="font-size:12px;color:#555;margin-top:6px">View Mode</label>
  <select id="selView" disabled>
    <option value="roadtype">Road Types</option>
    <option value="traffic">Traffic Flow</option>
    <option value="importance">Street Importance</option>
  </select>

  <div style="margin-top:10px;background:#FFF3CD;padding:8px;border-radius:6px;font-size:12px">
    <strong>üöß Simulation:</strong>
    <div>Click ‚ÄúClose/Reopen a Street‚Äù, then click a street on the map.</div>
    <button id="btnCloseMode" class="btn secondary" disabled>Close/Reopen a Street</button>
  </div>

  <button id="btnReset" class="btn warn" disabled>Reset Closures</button>
  <button id="btnClear" class="btn danger">Clear All</button>

  <div id="status" class="status">Ready. Draw a polygon or load current bounds.</div>
  <div id="stats" class="stats" style="display:none">
    <strong>Network Stats</strong>
    <div id="nodes">Nodes: 0</div>
    <div id="ways">Streets: 0</div>
  </div>

  <div class="legend">
    <strong id="lgTitle">Road Types:</strong>
    <div class="legend-item"><div class="legend-color" id="lg1" style="background:#FF4444"></div>Motorway</div>
    <div class="legend-item"><div class="legend-color" id="lg2" style="background:#FF8800"></div>Primary</div>
    <div class="legend-item"><div class="legend-color" id="lg3" style="background:#FFB700"></div>Secondary</div>
    <div class="legend-item"><div class="legend-color" id="lg4" style="background:#4CAF50"></div>Residential</div>
    <div class="legend-item"><div class="legend-color" id="lg5" style="background:#888"></div>Other</div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script src="https://unpkg.com/graphology/dist/graphology.umd.js"></script>
<script src="https://unpkg.com/graphology-metrics/dist/graphology-metrics.min.js"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>

<script>
class TrafficAnalyzer {
  constructor() {
    this.map=null; this.drawn=null; this.poly=null;
    this.graph=new graphology.Graph({type:'directed'});
    this.originalGraph=null;

    this.nodesById={}; this.ways={}; this.edgesByWay={}; this.layers={};
    this.baseTraffic={}; this.traffic={}; this.importance={}; this.closedWays=new Set();
    this.closeMode=false; this.viewMode='roadtype'; this.currentPeriod='';
    this.tomtom='2hRMy8jfLxTGLUhZ3UJNoqAlihmLd9PA';
    this.center=[44.8378,-0.5792]; this.zoom=14;
  }

  async init(){
    this.map=L.map('map').setView(this.center,this.zoom);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'¬© OpenStreetMap'}).addTo(this.map);
    this.drawn=new L.FeatureGroup().addTo(this.map);
    const drawCtl=new L.Control.Draw({draw:{polygon:{shapeOptions:{color:'#2196F3',fillOpacity:.2}},rectangle:{shapeOptions:{color:'#2196F3',fillOpacity:.2}},polyline:false,marker:false,circle:false,circlemarker:false},edit:{featureGroup:this.drawn,remove:true}});
    this.map.addControl(drawCtl);
    this.map.on(L.Draw.Event.CREATED,(e)=>{ this.drawn.clearLayers(); this.poly=e.layer; this.drawn.addLayer(this.poly); this.status('Polygon ready.'); });
    this.map.on(L.Draw.Event.DELETED,()=>{ this.poly=null; this.status('Polygon removed. You can load current bounds.'); });

    Q('#btnLoad').onclick=()=>this.loadOSM();
    Q('#btnClear').onclick=()=>this.clearAll();
    Q('#selPeriod').onchange=(e)=>{ if(e.target.value){ this.currentPeriod=e.target.value; this.loadTraffic(e.target.value);} };
    Q('#btnImportance').onclick=()=>this.calculateImportance();
    Q('#selView').onchange=(e)=>this.setView(e.target.value);
    Q('#btnReset').onclick=()=>this.resetClosures();
    Q('#btnCloseMode').onclick=()=>this.toggleCloseMode();

    this.status('Ready. Draw a polygon or click ‚ÄúLoad Street Network‚Äù.');
  }

  // UI helpers
  status(msg,loading=false){ Q('#status').innerHTML=loading?`<b style="color:#4CAF50">${msg}</b>`:msg; }
  updateLegendRoad(){ Q('#lgTitle').textContent='Road Types:'; S('#lg1','#FF4444','Motorway'); S('#lg2','#FF8800','Primary'); S('#lg3','#FFB700','Secondary'); S('#lg4','#4CAF50','Residential'); S('#lg5','#888','Other'); }
  updateLegendTraffic(){ Q('#lgTitle').textContent='Traffic Levels:'; S('#lg1','#22C55E','Free Flow'); S('#lg2','#FACC15','Light'); S('#lg3','#FB923C','Moderate'); S('#lg4','#EF4444','Heavy'); S('#lg5','#991B1B','Severe'); }
  updateLegendImportance(){ Q('#lgTitle').textContent='Importance:'; S('#lg1','#DC2626','Critical (80-100)'); S('#lg2','#F97316','Very Important (60-80)'); S('#lg3','#FACC15','Important (40-60)'); S('#lg4','#4ADE80','Moderate (20-40)'); S('#lg5','#60A5FA','Low (0-20)'); }
  roadColor(h){ const c={motorway:'#FF4444',motorway_link:'#FF4444',trunk:'#FF6644',trunk_link:'#FF6644',primary:'#FF8800',primary_link:'#FF8800',secondary:'#FFB700',secondary_link:'#FFB700',tertiary:'#FFDD00',residential:'#4CAF50',living_street:'#4CAF50',unclassified:'#999'}; return c[h]||'#888'; }
  roadWeight(h){ const w={motorway:4,trunk:4,primary:3,secondary:2,tertiary:2,residential:1.8,unclassified:1.6}; return w[h]||1.6; }
  congestionColor(r){ return r>0.8?'#22C55E':r>0.6?'#FACC15':r>0.4?'#FB923C':r>0.2?'#EF4444':'#991B1B'; }
  importanceColor(s){ return s>80?'#DC2626':s>60?'#F97316':s>40?'#FACC15':s>20?'#4ADE80':'#60A5FA'; }
  rank(s){ return s>80?'Critical':s>60?'Very Important':s>40?'Important':s>20?'Moderate':'Low'; }

  async loadOSM(){
    this.resetState(true);
    this.status('Loading street network‚Ä¶',true);

    let query;
    if(this.poly){
      const latlngs=this.poly.getLatLngs()[0]; if(!latlngs?.length){ this.status('Invalid polygon.'); return; }
      const polyStr=latlngs.map(ll=>`${ll.lat} ${ll.lng}`).join(' ');
      query=`[out:json][timeout:60];(way["highway"]["highway"!~"footway|path|cycleway|steps|pedestrian|service"](poly:"${polyStr}"););out body;>;out skel qt;`;
    } else {
      const b=this.map.getBounds(); const bbox=[b.getSouth(),b.getWest(),b.getNorth(),b.getEast()].join(',');
      query=`[out:json][timeout:60];way["highway"]["highway"!~"footway|path|cycleway|steps|pedestrian|service"](${bbox});(._;>;);out;`;
    }

    try{
      const {data}=await axios.post('https://overpass-api.de/api/interpreter',query,{headers:{'Content-Type':'text/plain'}});
      const els=data.elements||[];
      els.forEach(e=>{ if(e.type==='node') this.nodesById[e.id]={lat:e.lat,lon:e.lon}; });
      els.forEach(e=>{
        if(e.type==='way'&&e.tags?.highway&&e.nodes?.length>1){
          const coords=e.nodes.map(id=>this.nodesById[id]).filter(Boolean).map(n=>[n.lat,n.lon]);
          if(coords.length<2) return;
          this.ways[e.id]={wayId:e.id,name:e.tags.name||'Unnamed',highway:e.tags.highway,maxspeed:e.tags.maxspeed||'Unknown',coords,nodeIds:e.nodes.slice(),lenKm:this.lengthKm(coords),oneway:e.tags.oneway==='yes'};
        }
      });
      if(!Object.keys(this.ways).length){ this.status('No streets found.'); return; }

      this.buildCompressedGraph(); this.drawWays();
      this.originalGraph=this.graph.copy();
      Q('#stats').style.display='block';
      Q('#nodes').textContent=`Nodes: ${this.graph.order}`;
      Q('#ways').textContent=`Streets: ${Object.keys(this.ways).length}`;
      ['#selPeriod','#btnImportance','#selView','#btnReset','#btnCloseMode'].forEach(s=>Q(s).disabled=false);
      this.status(`‚úÖ Loaded ${Object.keys(this.ways).length} streets`);
    }catch(e){ console.error(e); this.status('Error loading street data. Try again.'); }
  }

  buildCompressedGraph(){
    this.graph.clear(); this.edgesByWay={};
    const deg={};
    Object.values(this.ways).forEach(w=>{
      for(let i=0;i<w.nodeIds.length-1;i++){ const a=w.nodeIds[i], b=w.nodeIds[i+1]; deg[a]=(deg[a]||0)+1; deg[b]=(deg[b]||0)+1; }
    });
    const addNode=(id)=>{ if(!this.graph.hasNode(id)){ const n=this.nodesById[id]; if(n) this.graph.addNode(id,{lat:n.lat,lon:n.lon}); } };

    Object.values(this.ways).forEach(w=>{
      this.edgesByWay[w.wayId]=[];
      const N=w.nodeIds.length; let i=0, seg=0;
      const oneway = w.oneway || (w.highway?.includes('_link'));
      while(i<N-1){
        let j=i+1; while(j<N-1 && (deg[w.nodeIds[j]]||0)===2) j++;
        const start=w.nodeIds[i], end=w.nodeIds[j];
        addNode(start); addNode(end);
        const segCoords=[]; for(let k=i;k<=j;k++){ const n=this.nodesById[w.nodeIds[k]]; if(n) segCoords.push([n.lat,n.lon]); }
        const lenKm=this.lengthKm(segCoords);
        const base={wayId:w.wayId,highway:w.highway,name:w.name,maxspeed:w.maxspeed,coords:segCoords,lenKm,weight:1};
        const keyF=`${w.wayId}:${seg}:f`, keyB=`${w.wayId}:${seg}:b`;
        this.graph.addEdgeWithKey(keyF,start,end,base);
        if(!oneway) this.graph.addEdgeWithKey(keyB,end,start,base);
        this.edgesByWay[w.wayId].push(keyF); if(!oneway) this.edgesByWay[w.wayId].push(keyB);
        seg++; i=j;
      }
    });
  }

  drawWays(){
    Object.values(this.layers).forEach(l=>this.map.removeLayer(l)); this.layers={};
    Object.values(this.ways).forEach(w=>{
      const layer=L.polyline(w.coords,{color:this.roadColor(w.highway),weight:this.roadWeight(w.highway),opacity:.85}).addTo(this.map);
      layer.bindPopup(this.popupHTML(w));
      layer.on('click',(e)=>this.onWayClick(w.wayId,e));
      this.layers[w.wayId]=layer;
    });
    this.updateLegendRoad();
  }

  async loadTraffic(period){
    this.status(`Loading ${period} traffic (snapshot)‚Ä¶`,true);
    this.baseTraffic={}; this.traffic={}; this.currentPeriod=period;
    const ways=Object.values(this.ways); let done=0, ok=0;
    for(const w of ways){
      const mid=w.coords[Math.floor(w.coords.length/2)];
      try{
        const url='https://api.tomtom.com/traffic/services/4/flowSegmentData/absolute/10/json';
        const {data}=await axios.get(url,{params:{key:this.tomtom,point:`${mid[0]},${mid[1]}`}}); // one call per way
        if(data?.flowSegmentData){
          const f=data.flowSegmentData;
          this.baseTraffic[w.wayId]={current:f.currentSpeed,free:f.freeFlowSpeed,confidence:f.confidence};
          ok++;
        }
      }catch(e){}
      done++; if(done%10===0) this.status(`Traffic: ${done}/${ways.length}‚Ä¶`,true);
    }
    this.applyPeriod(period);
    this.viewMode='traffic'; Q('#selView').value='traffic'; this.renderTraffic(); this.updateLegendTraffic();
    this.status(`‚úÖ Traffic loaded (${ok}/${ways.length})`);
  }

  applyPeriod(period){
    const factor = period==='morning'?0.75: period==='evening'?0.7: 1.05;
    const fresh={};
    Object.keys(this.ways).forEach(wid=>{
      const b=this.baseTraffic[wid]; if(!b) return;
      fresh[wid]={current:Math.max(5, Math.round(b.current*factor)), free:b.free, confidence:b.confidence};
    });
    this.traffic=fresh;
    this.recomputeNetworkLoadFromClosures(true);
  }

  renderTraffic(){
    for(const [wayId,layer] of Object.entries(this.layers)){
      const w=this.ways[wayId]; const t=this.traffic[wayId];
      if(!w||!layer) continue;
      if(t){
        const ratio=Math.max(0.01, t.current/Math.max(1,t.free));
        layer.setStyle({color:this.congestionColor(ratio),weight:4,opacity:.95});
        layer.setPopupContent(this.popupHTML(w, `<br><strong>Traffic</strong><br>Current: ${t.current} km/h<br>Free: ${t.free} km/h<br>Congestion: ${Math.round((1-ratio)*100)}%`));
      } else {
        layer.setStyle({color:'#bbb',weight:3,opacity:.6});
      }
    }
  }

  calculateImportance(){
    this.status('Calculating importance‚Ä¶',true);
    // edge cost = time*volume; seed from current traffic if available
    this.graph.forEachEdge((k,a)=>{
      const t=this.traffic[a.wayId]||this.baseTraffic[a.wayId];
      const speed=Math.max(5,(t?.current)||50), free=Math.max(5,(t?.free)||speed);
      const vol=1 + 0.6*Math.max(0,(free/speed)-1);
      const cost=(a.lenKm/ speed) * vol; // hours * volume
      this.graph.setEdgeAttribute(k,'cost',cost);
    });
    let nodeC=null;
    try{ if(window.graphologyMetrics?.centrality?.betweenness){ nodeC=window.graphologyMetrics.centrality.betweenness(this.graph,{weighted:'cost',normalized:true}); } }catch(e){}
    if(!nodeC) nodeC=this.betweennessUnweighted();

    const vals=[], wayTopo={};
    Object.entries(this.edgesByWay).forEach(([wid,ek])=>{
      let sum=0,cnt=0; ek.forEach(k=>{ if(this.graph.hasEdge(k)){ const u=this.graph.source(k), v=this.graph.target(k); sum+=((nodeC[u]||0)+(nodeC[v]||0))/2; cnt++; } });
      wayTopo[wid]=cnt?sum/cnt:0; vals.push(wayTopo[wid]);
    });
    const min=Math.min(...vals,0), max=Math.max(...vals,1), rng=(max-min)||1;
    this.importance={}; Object.keys(this.ways).forEach(wid=>{
      const topo=((wayTopo[wid]-min)/rng);
      const t=this.traffic[wid]||this.baseTraffic[wid];
      const cong=t?(1-Math.max(0,Math.min(1,(t.current/Math.max(1,t.free))))):0.2;
      this.importance[wid]=Math.round((0.6*topo+0.4*cong)*100);
    });

    this.viewMode='importance'; Q('#selView').value='importance';
    this.renderImportance(); this.updateLegendImportance();
    this.status('‚úÖ Importance calculated.');
  }

  renderImportance(){
    Object.entries(this.layers).forEach(([wid,layer])=>{
      const score=this.importance[wid]||0, w=this.ways[wid];
      const opacity=0.5 + 0.5*(score/100);
      layer.setStyle({color:this.importanceColor(score),weight:3+(score/25),opacity});
      layer.setPopupContent(this.popupHTML(w, `<br><strong>Importance</strong><br>Score: ${score}/100 (${this.rank(score)})`));
    });
  }

  betweennessUnweighted(){
    const nodes=this.graph.nodes(), B={}; nodes.forEach(n=>B[n]=0);
    nodes.forEach(s=>{
      const S=[], P={}, sigma={}, dist={};
      nodes.forEach(n=>{P[n]=[];sigma[n]=0;dist[n]=-1;});
      sigma[s]=1; dist[s]=0; const Qq=[s];
      while(Qq.length){
        const v=Qq.shift(); S.push(v);
        this.graph.outNeighbors(v).forEach(w=>{
          if(dist[w]<0){ Qq.push(w); dist[w]=dist[v]+1; }
          if(dist[w]===dist[v]+1){ sigma[w]+=sigma[v]; P[w].push(v); }
        });
      }
      const delta={}; nodes.forEach(n=>delta[n]=0);
      while(S.length){ const w=S.pop(); P[w].forEach(v=>{ delta[v]+= (sigma[v]/Math.max(1,sigma[w]))*(1+delta[w]); }); if(w!==s) B[w]+=delta[w]; }
    });
    const vals=Object.values(B); const M=Math.max(...vals,1); Object.keys(B).forEach(k=>B[k]=B[k]/M); return B;
  }

  setView(mode){
    this.viewMode=mode;
    if(mode==='roadtype'){ this.drawWays(); this.updateLegendRoad(); }
    else if(mode==='traffic'){
      if(Object.keys(this.baseTraffic).length){ this.renderTraffic(); this.updateLegendTraffic(); }
      else { alert('Load traffic data first'); Q('#selView').value='roadtype'; this.viewMode='roadtype'; this.updateLegendRoad(); }
    } else if(mode==='importance'){
      if(Object.keys(this.importance).length){ this.renderImportance(); this.updateLegendImportance(); }
      else { alert('Calculate importance first'); Q('#selView').value='roadtype'; this.viewMode='roadtype'; this.updateLegendRoad(); }
    }
  }

  toggleCloseMode(){
    this.closeMode=!this.closeMode;
    const b=Q('#btnCloseMode');
    if(this.closeMode){ b.textContent='Click a street to toggle closure (Click again to exit)'; b.style.background='#444'; this.status('Simulation armed: click a street to close/reopen.'); }
    else { b.textContent='Close/Reopen a Street'; b.style.background='#000'; this.status('Simulation mode off.'); }
  }

  onWayClick(wayId){
    if(!this.closeMode) return;
    if(this.closedWays.has(wayId)) this.reopenWay(wayId);
    else this.closeWay(wayId);
  }

  // CLOSED STREET: black dashed + flash; drop edges; redistribute traffic; animate alternatives
  closeWay(wayId){
    const layer=this.layers[wayId]; if(!layer) return;
    this.closedWays.add(wayId);
    layer.setStyle({color:'#000',opacity:.95,weight:6,dashArray:'10,8'}); layer.bringToFront();
    const el=layer.getElement?.(); if(el){ el.classList.add('closed'); el.classList.remove('altPulse'); }

    // remove edges for this way
    (this.edgesByWay[wayId]||[]).forEach(k=>{ if(this.graph.hasEdge(k)) this.graph.dropEdge(k); });

    // compute volume from closed way and redistribute
    const volume=this.computeClosedVolume(wayId);
    const {s,t}=this.wayEndpoints(wayId);
    const alts=this.findAlternatives(s,t,3,5); // BFS: up to 3 paths, max 5 hops
    this.redistributeTrafficVolume(volume, alts);

    // animate alternatives (red pulsing)
    this.animateAlternatives(alts);

    // repaint traffic if visible
    if(this.viewMode==='traffic') this.renderTraffic();
    this.status(`üöß Closed: ${this.ways[wayId]?.name || wayId}. Total closures: ${this.closedWays.size}.`);
  }

  reopenWay(wayId){
    const layer=this.layers[wayId]; if(!layer) return;
    this.closedWays.delete(wayId);
    const w=this.ways[wayId];
    layer.setStyle({color:this.roadColor(w.highway),weight:this.roadWeight(w.highway),opacity:.85,dashArray:null});
    const el=layer.getElement?.(); if(el){ el.classList.remove('closed'); el.classList.remove('altPulse'); }

    // re-add original edges
    this.originalGraph.forEachEdge((key,attrs,src,tgt)=>{ if(attrs.wayId===wayId && !this.graph.hasEdge(key)) this.graph.addEdgeWithKey(key,src,tgt,attrs); });

    // recompute network load from remaining closures (resets weights and re-applies)
    this.recomputeNetworkLoadFromClosures(true);
    this.status(`Reopened: ${w.name}. Total closures: ${this.closedWays.size}.`);
  }

  recomputeNetworkLoadFromClosures(repaint=false){
    // reset edge weights
    this.graph.forEachEdge((k,a)=>this.graph.setEdgeAttribute(k,'weight',1));
    // reset traffic to current period/base
    const fresh={}; const src = Object.keys(this.traffic).length? this.traffic : this.baseTraffic;
    Object.keys(src).forEach(wid=>{ fresh[wid]={...src[wid]}; });
    this.traffic=fresh;

    // apply all closures again
    this.closedWays.forEach(wid=>{
      const vol=this.computeClosedVolume(wid);
      const {s,t}=this.wayEndpoints(wid);
      const alts=this.findAlternatives(s,t,3,5);
      this.redistributeTrafficVolume(vol, alts);
    });
    if(repaint && this.viewMode==='traffic') this.renderTraffic();
  }

  // 2) Alternative Route Finding: BFS up to maxPaths, avoids closed (edges dropped), maxHops
  findAlternatives(source,target,maxPaths=3,maxHops=5){
    const paths=[]; const q=[[source]];
    while(q.length && paths.length<maxPaths){
      const p=q.shift(); const v=p[p.length-1];
      if(v===target && p.length>1){ paths.push(p); continue; }
      if((p.length-1)>=maxHops) continue;
      this.graph.outNeighbors(v).forEach(n=>{
        if(p.includes(n)) return;
        const k=this.graph.edge(v,n); if(!k) return; // closed or no edge
        const a=this.graph.getEdgeAttributes(k); if(this.closedWays.has(a.wayId)) return;
        q.push([...p,n]);
      });
    }
    // convert to edges
    return paths.map(p=>{ const edges=[]; for(let i=0;i<p.length-1;i++){ const k=this.graph.edge(p[i],p[i+1]); if(k) edges.push(k); } return edges; }).filter(e=>e.length);
  }

  // 3) Traffic Redistribution: compute volume, distribute to alternatives, update edge weights and speeds
  computeClosedVolume(wayId){
    const w=this.ways[wayId]; if(!w) return 0.5;
    const t=this.baseTraffic[wayId]||this.traffic[wayId]||{current:30,free:50};
    const vol = w.lenKm * (t.free/Math.max(5,t.current)); // rough demand units
    return Math.max(0.2, vol);
  }

  redistributeTrafficVolume(volume, altPaths){
    if(!altPaths.length) return;
    // path costs (inverse of travel-time attracts more)
    const eps=1e-3, pathCost=[], invs=[];
    altPaths.forEach(edges=>{
      let cost=0; edges.forEach(k=>{
        const a=this.graph.getEdgeAttributes(k);
        const t=this.traffic[a.wayId]||this.baseTraffic[a.wayId]||{current:40,free:50};
        const speed=Math.max(5,t.current); cost += (a.lenKm/ speed);
      }); pathCost.push(cost); invs.push(1/Math.max(eps,cost));
    });
    const invSum=invs.reduce((s,x)=>s+x,0)||1;

    // distribute volume across paths then across edges by length share; update edge weights and speeds
    const addedPerWay={};
    altPaths.forEach((edges,idx)=>{
      const pathShare=(invs[idx]/invSum);
      const pathVol=volume*pathShare;
      let totalLen=edges.reduce((s,k)=>s+(this.graph.getEdgeAttribute(k,'lenKm')||0.05),0.05);
      edges.forEach(k=>{
        const a=this.graph.getEdgeAttributes(k);
        const edgeShare=(a.lenKm||0.05)/totalLen;
        const edgeVol=pathVol*edgeShare;
        // bump edge weight
        const baseW=this.graph.getEdgeAttribute(k,'weight')||1;
        this.graph.setEdgeAttribute(k,'weight', baseW + edgeVol);
        // accumulate per-way pressure
        addedPerWay[a.wayId]=(addedPerWay[a.wayId]||0)+edgeVol;
      });
    });

    // adjust speeds for impacted ways (simple slowdown)
    Object.entries(addedPerWay).forEach(([wid,press])=>{
      const t=this.traffic[wid]; if(!t) return;
      const factor=1/(1+0.25*press);
      t.current=Math.max(5,Math.round(t.current*factor));
    });
  }

  // 4) Visual animations for alternatives
  animateAlternatives(altPaths){
    const seenWays=new Set();
    altPaths.forEach((edges,i)=>{
      edges.forEach(k=>{
        const a=this.graph.getEdgeAttributes(k); const wid=a.wayId; if(!wid||this.closedWays.has(wid)||seenWays.has(wid)) return;
        seenWays.add(wid); const layer=this.layers[wid]; if(!layer) return;
        layer.setStyle({color:'#E11D48',weight:5,opacity:.98}); layer.bringToFront();
        const el=layer.getElement?.(); if(el) el.classList.add('altPulse');
        setTimeout(()=>{ // revert style after pulse
          if(this.closedWays.has(wid)) return;
          if(this.viewMode==='traffic' && this.traffic[wid]){
            const t=this.traffic[wid]; const r=Math.max(0.01,t.current/Math.max(1,t.free));
            layer.setStyle({color:this.congestionColor(r),weight:4,opacity:.95});
          } else if(this.viewMode==='importance' && this.importance[wid]!=null){
            const s=this.importance[wid]; layer.setStyle({color:this.importanceColor(s),weight:3+(s/25),opacity:.95});
          } else {
            const w=this.ways[wid]; layer.setStyle({color:this.roadColor(w.highway),weight:this.roadWeight(w.highway),opacity:.85});
          }
          const el2=layer.getElement?.(); if(el2) el2.classList.remove('altPulse');
        }, 2800 + i*120);
      });
    });
  }

  wayEndpoints(wid){ const w=this.ways[wid]; return {s:w.nodeIds[0], t:w.nodeIds[w.nodeIds.length-1]}; }

  resetClosures(){
    Array.from(this.closedWays).forEach(wid=>this.reopenWay(wid));
    this.closedWays.clear();
    this.graph=this.originalGraph.copy();
    this.recomputeNetworkLoadFromClosures(true);
    this.status('‚úÖ All closures reset.');
  }

  clearAll(){
    if(this.drawn) this.drawn.clearLayers();
    Object.values(this.layers).forEach(l=>this.map.removeLayer(l)); this.layers={};
    this.resetState(false);
    this.status('Cleared. Draw a polygon or load current bounds.');
  }

  resetState(disableButtons){
    this.nodesById={}; this.ways={}; this.edgesByWay={}; this.layers={};
    this.baseTraffic={}; this.traffic={}; this.importance={}; this.closedWays.clear();
    this.graph.clear(); this.originalGraph=null; this.viewMode='roadtype'; this.currentPeriod='';
    Q('#selView').value='roadtype'; Q('#selPeriod').value='';
    ['#selPeriod','#btnImportance','#selView','#btnReset','#btnCloseMode'].forEach(s=>Q(s).disabled=disableButtons);
    Q('#stats').style.display='none';
  }

  // Utils
  popupHTML(w,extra=''){ return `<div class="street-popup"><strong>${esc(w.name)}</strong><br>Type: ${esc(w.highway)}<br>Max Speed: ${esc(w.maxspeed)}<br>Way ID: ${w.wayId}${extra}</div>`; }
  lengthKm(coords){ let d=0; for(let i=0;i<coords.length-1;i++) d+=this.haversine(coords[i],coords[i+1]); return d; }
  haversine(a,b){ const R=6371, toRad=x=>x*Math.PI/180, dLat=toRad(b[0]-a[0]), dLon=toRad(b[1]-a[1]); const s1=Math.sin(dLat/2), s2=Math.sin(dLon/2); const q=s1*s1+Math.cos(toRad(a[0]))*Math.cos(toRad(b[0]))*s2*s2; return 2*R*Math.asin(Math.sqrt(q)); }
}

// DOM helpers
function Q(s){ return document.querySelector(s); }
function S(id,color,label){ Q(id).style.background=color; Q(id).parentElement.lastChild.nodeValue=' '+label; }
function esc(s){ return String(s??'').replace(/[&<>"']/g,c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c])); }

const app=new TrafficAnalyzer(); app.init();
</script>
</body>
</html>
