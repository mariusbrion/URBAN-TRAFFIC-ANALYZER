<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Analyseur de Trafic Urbain</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
<style>
  :root {
    --primary-color: #4CAF50;
    --secondary-color: #2196F3;
    --danger-color: #f44336;
    --warn-color: #FF9800;
    --dark-color: #333;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Open Sans','Helvetica Neue',sans-serif;height:100vh;overflow:hidden; background-color: #f0f2f5;}
  #map{height:100vh}
  .panel{position:absolute;top:10px;right:10px;background:#fff;padding:16px;border-radius:12px;box-shadow:0 4px 15px rgba(0,0,0,.15);z-index:1000;width:320px;max-height:calc(100vh - 20px);overflow-y:auto; font-size: 14px;}
  .panel h3{margin:0 0 12px; font-size: 20px; display: flex; align-items: center;}
  .panel h3:before { content: 'üö¶'; margin-right: 8px; }
  .hint{font-size:12px;background:#e3f2fd;color:#1976d2;padding:8px 12px;border-radius:6px;margin-bottom:12px; line-height: 1.4;}
  .btn,select{width:100%;padding:10px;margin:6px 0;border:1px solid transparent;border-radius:8px;background:var(--primary-color);color:#fff;cursor:pointer; font-weight: 500; transition: background-color 0.2s ease, box-shadow 0.2s ease;}
  .btn:hover:not(:disabled) { filter: brightness(1.1); box-shadow: 0 2px 5px rgba(0,0,0,.1); }
  .btn:disabled{background:#ccc;cursor:not-allowed}
  .btn.secondary{background:var(--dark-color)}.btn.warn{background:var(--warn-color)}.btn.danger{background:var(--danger-color)}
  #btnCloseMode.active { background-color: #c62828; animation: pulse-red 1.5s infinite; }
  .status{background:#f7f7f7;padding:10px;border-radius:6px;font-size:13px;margin-top:12px; border-left: 4px solid var(--secondary-color);}
  .legend{margin-top:12px;background:#f9f9f9;padding:12px;border-radius:6px;font-size:13px}
  .legend-item{display:flex;align-items:center;margin:6px 0}
  .legend-color{width:30px;height:4px;margin-right:10px; border-radius: 2px;}
  .stats{margin-top:12px;background:#e8f5e9;padding:12px;border-radius:6px;font-size:13px}
  .street-popup{font-size:13px; line-height: 1.5;}
  label { font-size:13px; color:#555; margin-top:8px; display: block; font-weight: 500; }
  .simulation-box { margin-top:12px; background:#fff3cd; padding:12px; border-radius:8px; font-size:13px; border-left: 4px solid #ffc107; }
  /* Animations */
  .closed{animation:flash-black 1.2s ease-in-out infinite}
  @keyframes flash-black{0%,100%{opacity:.6}50%{opacity:1}}
  .altPulse{animation:pulse-red 1.8s ease-in-out infinite}
  @keyframes pulse-red{0%,100%{opacity:.7}50%{opacity:1}}
</style>
</head>
<body>
<div id="map"></div>

<div class="panel">
  <h3>Analyseur de Trafic</h3>
  <div class="hint">Dessinez un polygone ou utilisez la vue actuelle, puis cliquez sur "Charger le r√©seau".</div>

  <button id="btnLoad" class="btn">Charger le r√©seau routier</button>

  <label for="selPeriod">P√©riode de trafic</label>
  <select id="selPeriod" disabled>
    <option value="">S√©lectionner une p√©riode...</option>
    <option value="morning">Heure de pointe (matin 7h-9h)</option>
    <option value="evening">Heure de pointe (soir 17h-19h)</option>
    <option value="offpeak">Heures creuses (14h-16h)</option>
  </select>

  <button id="btnImportance" class="btn" style="background:#9C27B0" disabled>Calculer l'importance</button>

  <label for="selView">Mode d'affichage</label>
  <select id="selView" disabled>
    <option value="roadtype">Types de routes</option>
    <option value="traffic">Flux de trafic</option>
    <option value="importance">Importance des rues</option>
  </select>

  <div class="simulation-box">
    <strong>üöß Simulation:</strong>
    <div>Cliquez sur "Activer/D√©sactiver la fermeture" puis cliquez sur une rue sur la carte.</div>
    <button id="btnCloseMode" class="btn secondary" disabled>Activer/D√©sactiver la fermeture</button>
  </div>

  <button id="btnReset" class="btn warn" disabled>R√©initialiser les fermetures</button>
  <button id="btnClear" class="btn danger">Tout effacer</button>

  <div id="status" class="status">Pr√™t. Dessinez un polygone ou chargez la zone visible.</div>
  <div id="stats" class="stats" style="display:none">
    <strong>Statistiques du r√©seau</strong>
    <div id="nodes">N≈ìuds : 0</div>
    <div id="ways">Rues : 0</div>
  </div>

  <div class="legend">
    <strong id="lgTitle">Types de routes :</strong>
    <div class="legend-item"><div class="legend-color" id="lg1" style="background:#FF4444"></div>Autoroute</div>
    <div class="legend-item"><div class="legend-color" id="lg2" style="background:#FF8800"></div>Primaire</div>
    <div class="legend-item"><div class="legend-color" id="lg3" style="background:#FFB700"></div>Secondaire</div>
    <div class="legend-item"><div class="legend-color" id="lg4" style="background:#4CAF50"></div>R√©sidentiel</div>
    <div class="legend-item"><div class="legend-color" id="lg5" style="background:#888"></div>Autre</div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script src="https://unpkg.com/graphology/dist/graphology.umd.js"></script>
<script src="https://unpkg.com/graphology-metrics/dist/graphology-metrics.min.js"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>

<script>
// Helpers DOM
const Q = (s) => document.querySelector(s);
const S = (id, color, label) => { Q(id).style.background = color; Q(id).parentElement.lastChild.nodeValue = ' ' + label; };
const esc = (s) => String(s ?? '').replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]));

class TrafficAnalyzer {
  constructor() {
    this.map = null; this.drawn = null; this.poly = null;
    this.graph = new graphology.Graph({ type: 'directed' });
    this.originalGraph = null;

    this.nodesById = {}; this.ways = {}; this.edgesByWay = {}; this.layers = {};
    this.baseTraffic = {}; this.traffic = {}; this.importance = {}; this.closedWays = new Set();
    this.closeMode = false; this.viewMode = 'roadtype'; this.currentPeriod = '';
    this.tomtomApiKey = '2hRMy8jfLxTGLUhZ3UJNoqAlihmLd9PA'; // Remplacez par votre cl√© si n√©cessaire
    this.center = [44.8378, -0.5792]; // Bordeaux
    this.zoom = 14;
  }

  init() {
    this.map = L.map('map').setView(this.center, this.zoom);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '¬© OpenStreetMap' }).addTo(this.map);
    this.drawn = new L.FeatureGroup().addTo(this.map);
    const drawCtl = new L.Control.Draw({ draw: { polygon: { shapeOptions: { color: '#2196F3', fillOpacity: .2 } }, rectangle: { shapeOptions: { color: '#2196F3', fillOpacity: .2 } }, polyline: false, marker: false, circle: false, circlemarker: false }, edit: { featureGroup: this.drawn, remove: true } });
    this.map.addControl(drawCtl);
    this.map.on(L.Draw.Event.CREATED, (e) => { this.drawn.clearLayers(); this.poly = e.layer; this.drawn.addLayer(this.poly); this.status('Polygone pr√™t.'); });
    this.map.on(L.Draw.Event.DELETED, () => { this.poly = null; this.status('Polygone retir√©. Vous pouvez charger la vue actuelle.'); });

    Q('#btnLoad').onclick = () => this.loadOSM();
    Q('#btnClear').onclick = () => this.clearAll();
    Q('#selPeriod').onchange = (e) => { if (e.target.value) { this.currentPeriod = e.target.value; this.loadTraffic(e.target.value); } };
    Q('#btnImportance').onclick = () => this.calculateImportance();
    Q('#selView').onchange = (e) => this.setView(e.target.value);
    Q('#btnReset').onclick = () => this.resetClosures();
    Q('#btnCloseMode').onclick = () => this.toggleCloseMode();

    this.status('Pr√™t. Dessinez un polygone ou cliquez sur "Charger le r√©seau routier".');
  }

  // UI helpers
  status(msg, loading = false) { Q('#status').innerHTML = loading ? `<strong>${msg}</strong>` : msg; }
  updateLegendRoad() { Q('#lgTitle').textContent = 'Types de routes:'; S('#lg1', '#FF4444', 'Autoroute'); S('#lg2', '#FF8800', 'Primaire'); S('#lg3', '#FFB700', 'Secondaire'); S('#lg4', '#4CAF50', 'R√©sidentiel'); S('#lg5', '#888', 'Autre'); }
  updateLegendTraffic() { Q('#lgTitle').textContent = 'Niveaux de trafic:'; S('#lg1', '#22C55E', 'Fluide'); S('#lg2', '#FACC15', 'L√©ger'); S('#lg3', '#FB923C', 'Mod√©r√©'); S('#lg4', '#EF4444', 'Dense'); S('#lg5', '#991B1B', 'Satur√©'); }
  updateLegendImportance() { Q('#lgTitle').textContent = 'Importance:'; S('#lg1', '#DC2626', 'Critique (80-100)'); S('#lg2', '#F97316', 'Tr√®s Important (60-80)'); S('#lg3', '#FACC15', 'Important (40-60)'); S('#lg4', '#4ADE80', 'Mod√©r√© (20-40)'); S('#lg5', '#60A5FA', 'Faible (0-20)'); }
  roadColor = (h) => ({ motorway: '#FF4444', motorway_link: '#FF4444', trunk: '#FF6644', trunk_link: '#FF6644', primary: '#FF8800', primary_link: '#FF8800', secondary: '#FFB700', secondary_link: '#FFB700', tertiary: '#FFDD00', residential: '#4CAF50', living_street: '#4CAF50', unclassified: '#999' }[h] || '#888');
  roadWeight = (h) => ({ motorway: 4, trunk: 4, primary: 3, secondary: 2.5, tertiary: 2, residential: 1.8, unclassified: 1.6 }[h] || 1.6);
  congestionColor = (r) => r > 0.8 ? '#22C55E' : r > 0.6 ? '#FACC15' : r > 0.4 ? '#FB923C' : r > 0.2 ? '#EF4444' : '#991B1B';
  importanceColor = (s) => s > 80 ? '#DC2626' : s > 60 ? '#F97316' : s > 40 ? '#FACC15' : s > 20 ? '#4ADE80' : '#60A5FA';
  rank = (s) => s > 80 ? 'Critique' : s > 60 ? 'Tr√®s Important' : s > 40 ? 'Important' : s > 20 ? 'Mod√©r√©' : 'Faible';

  async loadOSM() {
    this.resetState(true); this.status('Chargement du r√©seau routier...', true);
    let query;
    if (this.poly) {
      const latlngs = this.poly.getLatLngs()[0]; if (!latlngs?.length) { this.status('Polygone invalide.'); return; }
      const polyStr = latlngs.map(ll => `${ll.lat} ${ll.lng}`).join(' ');
      query = `[out:json][timeout:60];(way["highway"]["highway"!~"footway|path|cycleway|steps|pedestrian|service|track|bridleway|corridor"](poly:"${polyStr}"););out body;>;out skel qt;`;
    } else {
      const b = this.map.getBounds(); const bbox = [b.getSouth(), b.getWest(), b.getNorth(), b.getEast()].join(',');
      query = `[out:json][timeout:60];way["highway"]["highway"!~"footway|path|cycleway|steps|pedestrian|service|track|bridleway|corridor"](${bbox});(._;>;);out;`;
    }
    try {
      const { data } = await axios.post('https://overpass-api.de/api/interpreter', query, { headers: { 'Content-Type': 'text/plain' } });
      const els = data.elements || [];
      els.forEach(e => { if (e.type === 'node') this.nodesById[e.id] = { lat: e.lat, lon: e.lon }; });
      els.forEach(e => {
        if (e.type === 'way' && e.tags?.highway && e.nodes?.length > 1) {
          const coords = e.nodes.map(id => this.nodesById[id]).filter(Boolean).map(n => [n.lat, n.lon]);
          if (coords.length < 2) return;
          this.ways[e.id] = { wayId: e.id, name: e.tags.name || 'Sans nom', highway: e.tags.highway, maxspeed: e.tags.maxspeed || 'Inconnue', coords, nodeIds: e.nodes.slice(), lenKm: this.lengthKm(coords), oneway: e.tags.oneway === 'yes' };
        }
      });
      if (!Object.keys(this.ways).length) { this.status('Aucune rue trouv√©e.'); return; }
      this.buildCompressedGraph(); this.drawWays(); this.originalGraph = this.graph.copy();
      Q('#stats').style.display = 'block'; Q('#nodes').textContent = `N≈ìuds: ${this.graph.order}`; Q('#ways').textContent = `Rues: ${Object.keys(this.ways).length}`;
      ['#selPeriod', '#btnImportance', '#selView', '#btnReset', '#btnCloseMode'].forEach(s => Q(s).disabled = false);
      this.status(`‚úÖ ${Object.keys(this.ways).length} rues charg√©es.`);
    } catch (e) { console.error(e); this.status('Erreur de chargement. Essayez une zone plus petite.'); }
  }

  buildCompressedGraph() {
    this.graph.clear(); this.edgesByWay = {}; const deg = {};
    Object.values(this.ways).forEach(w => { w.nodeIds.forEach(id => deg[id] = (deg[id] || 0) + 1); });
    const addNode = (id) => { if (!this.graph.hasNode(id)) { const n = this.nodesById[id]; if (n) this.graph.addNode(id, { lat: n.lat, lon: n.lon }); } };
    Object.values(this.ways).forEach(w => {
      this.edgesByWay[w.wayId] = []; const N = w.nodeIds.length; let i = 0, seg = 0;
      const oneway = w.oneway || (w.highway?.includes('_link'));
      while (i < N - 1) {
        let j = i + 1; while (j < N - 1 && (deg[w.nodeIds[j]] || 0) === 2) j++;
        const start = w.nodeIds[i], end = w.nodeIds[j]; addNode(start); addNode(end);
        const segCoords = w.coords.slice(i, j + 1); const lenKm = this.lengthKm(segCoords);
        const base = { wayId: w.wayId, highway: w.highway, name: w.name, maxspeed: w.maxspeed, coords: segCoords, lenKm, weight: 1 };
        const keyF = `${w.wayId}:${seg}:f`; this.graph.addEdgeWithKey(keyF, start, end, base); this.edgesByWay[w.wayId].push(keyF);
        if (!oneway) { const keyB = `${w.wayId}:${seg}:b`; this.graph.addEdgeWithKey(keyB, end, start, base); this.edgesByWay[w.wayId].push(keyB); }
        seg++; i = j;
      }
    });
  }

  drawWays() {
    Object.values(this.layers).forEach(l => this.map.removeLayer(l)); this.layers = {};
    Object.values(this.ways).forEach(w => {
      const layer = L.polyline(w.coords, { color: this.roadColor(w.highway), weight: this.roadWeight(w.highway), opacity: .85 }).addTo(this.map);
      layer.bindPopup(this.popupHTML(w)); layer.on('click', (e) => this.onWayClick(w.wayId, e)); this.layers[w.wayId] = layer;
    });
    this.updateLegendRoad();
  }

  async loadTraffic(period) {
    this.status(`Chargement du trafic (${period})...`, true);
    this.baseTraffic = {}; this.traffic = {}; this.currentPeriod = period; const ways = Object.values(this.ways); let done = 0, ok = 0;
    for (const w of ways) {
      const mid = w.coords[Math.floor(w.coords.length / 2)];
      try {
        const url = 'https://api.tomtom.com/traffic/services/4/flowSegmentData/absolute/10/json';
        const { data } = await axios.get(url, { params: { key: this.tomtomApiKey, point: `${mid[0]},${mid[1]}` } });
        if (data?.flowSegmentData) { const f = data.flowSegmentData; this.baseTraffic[w.wayId] = { current: f.currentSpeed, free: f.freeFlowSpeed, confidence: f.confidence }; ok++; }
      } catch (e) { /* ignore errors for individual ways */ }
      done++; if (done % 10 === 0) this.status(`Trafic: ${done}/${ways.length}...`, true);
    }
    this.applyPeriod(period); this.viewMode = 'traffic'; Q('#selView').value = 'traffic'; this.renderTraffic(); this.updateLegendTraffic();
    this.status(`‚úÖ Trafic charg√© (${ok}/${ways.length})`);
  }

  applyPeriod(period) {
    const factor = period === 'morning' ? 0.75 : period === 'evening' ? 0.7 : 1.05;
    const fresh = {};
    Object.keys(this.ways).forEach(wid => {
      const b = this.baseTraffic[wid]; if (!b) return;
      fresh[wid] = { current: Math.max(5, Math.round(b.current * factor)), free: b.free, confidence: b.confidence };
    });
    this.traffic = fresh; this.recomputeNetworkLoadFromClosures(true);
  }

  renderTraffic() {
    for (const [wayId, layer] of Object.entries(this.layers)) {
      const w = this.ways[wayId]; const t = this.traffic[wayId]; if (!w || !layer) continue;
      if (t) {
        const ratio = Math.max(0.01, t.current / Math.max(1, t.free)); layer.setStyle({ color: this.congestionColor(ratio), weight: 4, opacity: .95 });
        layer.setPopupContent(this.popupHTML(w, `<br><strong>Trafic</strong><br>Actuelle: ${t.current} km/h<br>Libre: ${t.free} km/h<br>Congestion: ${Math.round((1 - ratio) * 100)}%`));
      } else { layer.setStyle({ color: '#bbb', weight: 3, opacity: .6 }); }
    }
  }

  calculateImportance() {
    this.status('Calcul de l\'importance...', true);
    this.graph.forEachEdge((k, a) => {
      const t = this.traffic[a.wayId] || this.baseTraffic[a.wayId];
      const speed = Math.max(5, (t?.current) || 50), free = Math.max(5, (t?.free) || speed);
      const vol = 1 + 0.6 * Math.max(0, (free / speed) - 1);
      this.graph.setEdgeAttribute(k, 'cost', (a.lenKm / speed) * vol);
    });
    let nodeC = null;
    try { if (window.graphologyMetrics?.centrality?.betweenness) { nodeC = window.graphologyMetrics.centrality.betweenness(this.graph, { weighted: 'cost', normalized: true }); } } catch (e) { }
    if (!nodeC) nodeC = this.betweennessUnweighted();
    const vals = [], wayTopo = {};
    Object.entries(this.edgesByWay).forEach(([wid, ek]) => {
      let sum = 0, cnt = 0; ek.forEach(k => { if (this.graph.hasEdge(k)) { const u = this.graph.source(k), v = this.graph.target(k); sum += ((nodeC[u] || 0) + (nodeC[v] || 0)) / 2; cnt++; } });
      wayTopo[wid] = cnt ? sum / cnt : 0; vals.push(wayTopo[wid]);
    });
    const min = Math.min(...vals, 0), max = Math.max(...vals, 1), rng = (max - min) || 1;
    this.importance = {};
    Object.keys(this.ways).forEach(wid => {
      const topo = ((wayTopo[wid] - min) / rng);
      const t = this.traffic[wid] || this.baseTraffic[wid];
      const cong = t ? (1 - Math.max(0, Math.min(1, (t.current / Math.max(1, t.free))))) : 0.2;
      this.importance[wid] = Math.round((0.6 * topo + 0.4 * cong) * 100);
    });
    this.viewMode = 'importance'; Q('#selView').value = 'importance'; this.renderImportance(); this.updateLegendImportance();
    this.status('‚úÖ Importance calcul√©e.');
  }

  renderImportance() {
    Object.entries(this.layers).forEach(([wid, layer]) => {
      const score = this.importance[wid] || 0, w = this.ways[wid];
      const opacity = 0.5 + 0.5 * (score / 100);
      layer.setStyle({ color: this.importanceColor(score), weight: 3 + (score / 25), opacity });
      layer.setPopupContent(this.popupHTML(w, `<br><strong>Importance</strong><br>Score: ${score}/100 (${this.rank(score)})`));
    });
  }

  betweennessUnweighted() {
    const nodes = this.graph.nodes(), B = {}; nodes.forEach(n => B[n] = 0);
    nodes.forEach(s => {
      const S = [], P = {}, sigma = {}, dist = {}; nodes.forEach(n => { P[n] = []; sigma[n] = 0; dist[n] = -1; });
      sigma[s] = 1; dist[s] = 0; const Qq = [s];
      while (Qq.length) {
        const v = Qq.shift(); S.push(v);
        this.graph.outNeighbors(v).forEach(w => {
          if (dist[w] < 0) { Qq.push(w); dist[w] = dist[v] + 1; }
          if (dist[w] === dist[v] + 1) { sigma[w] += sigma[v]; P[w].push(v); }
        });
      }
      const delta = {}; nodes.forEach(n => delta[n] = 0);
      while (S.length) { const w = S.pop(); P[w].forEach(v => { delta[v] += (sigma[v] / Math.max(1, sigma[w])) * (1 + delta[w]); }); if (w !== s) B[w] += delta[w]; }
    });
    const vals = Object.values(B); const M = Math.max(...vals, 1); Object.keys(B).forEach(k => B[k] /= M); return B;
  }

  setView(mode) {
    this.viewMode = mode;
    if (mode === 'roadtype') { this.drawWays(); this.updateLegendRoad(); }
    else if (mode === 'traffic') {
      if (Object.keys(this.baseTraffic).length) { this.renderTraffic(); this.updateLegendTraffic(); }
      else { alert('Chargez les donn√©es de trafic d\'abord.'); Q('#selView').value = 'roadtype'; this.viewMode = 'roadtype'; }
    } else if (mode === 'importance') {
      if (Object.keys(this.importance).length) { this.renderImportance(); this.updateLegendImportance(); }
      else { alert('Calculez l\'importance d\'abord.'); Q('#selView').value = 'roadtype'; this.viewMode = 'roadtype'; }
    }
  }

  toggleCloseMode() {
    this.closeMode = !this.closeMode; const b = Q('#btnCloseMode');
    if (this.closeMode) { b.textContent = 'Mode fermeture ACTIF (cliquez pour sortir)'; b.classList.add('active'); this.status('Simulation : cliquez une rue pour la fermer/rouvrir.'); }
    else { b.textContent = 'Activer/D√©sactiver la fermeture'; b.classList.remove('active'); this.status('Mode simulation d√©sactiv√©.'); }
  }

  onWayClick(wayId) {
    if (!this.closeMode || !this.originalGraph) return;
    if (this.closedWays.has(wayId)) this.reopenWay(wayId); else this.closeWay(wayId);
  }

  closeWay(wayId) {
    const layer = this.layers[wayId]; if (!layer) return; this.closedWays.add(wayId);
    layer.setStyle({ color: '#000', opacity: .95, weight: 6, dashArray: '10, 8' }); layer.bringToFront();
    layer.getElement()?.classList.add('closed');
    (this.edgesByWay[wayId] || []).forEach(k => { if (this.graph.hasEdge(k)) this.graph.dropEdge(k); });
    const volume = this.computeClosedVolume(wayId); const { s, t } = this.wayEndpoints(wayId);
    const alts = this.findAlternatives(s, t, 3, 8); // Trouve jusqu'√† 3 alternatives, max 8 segments
    if (!alts.length) {
      this.status(`üöß Rue ferm√©e, mais aucun itin√©raire alternatif simple n'a √©t√© trouv√©.`);
      if (this.viewMode === 'traffic') this.renderTraffic(); return;
    }
    this.redistributeTrafficVolume(volume, alts); this.animateAlternatives(alts);
    if (this.viewMode === 'traffic') this.renderTraffic();
    this.status(`üöß Ferm√©: ${this.ways[wayId]?.name || wayId}. Fermetures: ${this.closedWays.size}.`);
  }

  reopenWay(wayId) {
    const layer = this.layers[wayId]; if (!layer) return; this.closedWays.delete(wayId);
    const w = this.ways[wayId];
    this.originalGraph.forEachEdge((key, attrs, src, tgt) => { if (attrs.wayId === wayId && !this.graph.hasEdge(key)) this.graph.addEdgeWithKey(key, src, tgt, attrs); });
    layer.getElement()?.classList.remove('closed', 'altPulse');
    this.recomputeNetworkLoadFromClosures(true);
    this.status(`Ouvert: ${w.name || wayId}. Fermetures: ${this.closedWays.size}.`);
  }

  recomputeNetworkLoadFromClosures(repaint = false) {
    const fresh = {}; const src = Object.keys(this.baseTraffic).length ? this.baseTraffic : {};
    Object.keys(src).forEach(wid => { fresh[wid] = { ...src[wid] }; });
    this.traffic = fresh;
    this.closedWays.forEach(wid => {
      const vol = this.computeClosedVolume(wid); const { s, t } = this.wayEndpoints(wid);
      const alts = this.findAlternatives(s, t, 3, 8);
      this.redistributeTrafficVolume(vol, alts);
    });
    if (repaint) this.setView(this.viewMode);
  }

  findAlternatives(source, target, maxPaths = 3, maxHops = 8) {
    const paths = []; const q = [[source]];
    while (q.length && paths.length < maxPaths) {
      const p = q.shift(); const v = p[p.length - 1];
      if (v === target && p.length > 1) { paths.push(p); continue; }
      if ((p.length - 1) >= maxHops) continue;
      this.graph.outNeighbors(v).forEach(n => {
        if (p.includes(n)) return;
        const k = this.graph.edge(v, n); if (!k) return;
        q.push([...p, n]);
      });
    }
    return paths.map(p => { const edges = []; for (let i = 0; i < p.length - 1; i++) { const k = this.graph.edge(p[i], p[i + 1]); if (k) edges.push(k); } return edges; }).filter(e => e.length);
  }

  computeClosedVolume(wayId) {
    const w = this.ways[wayId]; if (!w) return 0.5;
    const t = this.baseTraffic[wayId] || { current: 30, free: 50 };
    const vol = w.lenKm * (t.free / Math.max(5, t.current)); return Math.max(0.2, vol);
  }

  redistributeTrafficVolume(volume, altPaths) {
    if (!altPaths.length) return;
    const pathCosts = altPaths.map(edges => edges.reduce((cost, k) => {
        const a = this.graph.getEdgeAttributes(k); const t = this.traffic[a.wayId] || this.baseTraffic[a.wayId] || { current: 40 };
        return cost + (a.lenKm / Math.max(5, t.current));
      }, 0));
    const invCosts = pathCosts.map(c => 1 / Math.max(1e-4, c)); const invSum = invCosts.reduce((s, x) => s + x, 0) || 1;
    const addedPerWay = {};
    altPaths.forEach((edges, idx) => {
      const pathShare = invCosts[idx] / invSum; const pathVol = volume * pathShare;
      const totalLen = edges.reduce((s, k) => s + this.graph.getEdgeAttribute(k, 'lenKm'), 0.01);
      edges.forEach(k => {
        const a = this.graph.getEdgeAttributes(k);
        const edgeVol = pathVol * (a.lenKm / totalLen);
        addedPerWay[a.wayId] = (addedPerWay[a.wayId] || 0) + edgeVol;
      });
    });
    Object.entries(addedPerWay).forEach(([wid, press]) => {
      const t = this.traffic[wid]; if (!t) return;
      const factor = 1 / (1 + 0.4 * press); // Impact plus prononc√©
      t.current = Math.max(5, Math.round(t.current * factor));
    });
  }

  animateAlternatives(altPaths) {
    const seenWays = new Set();
    altPaths.forEach((edges) => {
      edges.forEach(k => {
        const a = this.graph.getEdgeAttributes(k); const wid = a.wayId; if (!wid || this.closedWays.has(wid) || seenWays.has(wid)) return;
        seenWays.add(wid); const layer = this.layers[wid]; if (!layer) return;
        layer.setStyle({ color: '#E11D48', weight: 5, opacity: .98 }); layer.bringToFront();
        layer.getElement()?.classList.add('altPulse');
        setTimeout(() => {
          if (this.closedWays.has(wid) || !this.layers[wid]) return;
          const currentLayer = this.layers[wid];
          currentLayer.getElement()?.classList.remove('altPulse');
          this.setView(this.viewMode); // Redessine avec les bonnes couleurs apr√®s l'animation
        }, 2800);
      });
    });
  }

  wayEndpoints = (wid) => { const w = this.ways[wid]; return { s: w.nodeIds[0], t: w.nodeIds[w.nodeIds.length - 1] }; }

  resetClosures() {
    this.graph = this.originalGraph.copy();
    Array.from(this.closedWays).forEach(wid => {
      const layer = this.layers[wid]; if (!layer) return;
      layer.getElement()?.classList.remove('closed', 'altPulse');
    });
    this.closedWays.clear(); this.recomputeNetworkLoadFromClosures(true);
    this.status('‚úÖ Toutes les fermetures ont √©t√© r√©initialis√©es.');
  }

  clearAll() {
    if (this.drawn) this.drawn.clearLayers();
    Object.values(this.layers).forEach(l => this.map.removeLayer(l)); this.layers = {};
    this.resetState(false); this.status('Effac√©. Dessinez un polygone ou chargez la zone visible.');
  }

  resetState(disableButtons) {
    this.nodesById = {}; this.ways = {}; this.edgesByWay = {}; this.layers = {}; this.baseTraffic = {}; this.traffic = {}; this.importance = {};
    this.closedWays.clear(); this.graph.clear(); this.originalGraph = null;
    this.viewMode = 'roadtype'; this.currentPeriod = ''; Q('#selView').value = 'roadtype'; Q('#selPeriod').value = '';
    ['#selPeriod', '#btnImportance', '#selView', '#btnReset', '#btnCloseMode'].forEach(s => Q(s).disabled = disableButtons);
    Q('#stats').style.display = 'none';
  }

  // Utils
  popupHTML(w, extra = '') { return `<div class="street-popup"><strong>${esc(w.name)}</strong><br>Type: ${esc(w.highway)}<br>Vitesse max: ${esc(w.maxspeed)}<br>ID: ${w.wayId}${extra}</div>`; }
  lengthKm(coords) { let d = 0; for (let i = 0; i < coords.length - 1; i++) d += this.haversine(coords[i], coords[i + 1]); return d; }
  haversine(a, b) { const R = 6371, toRad = x => x * Math.PI / 180, dLat = toRad(b[0] - a[0]), dLon = toRad(b[1] - a[1]); const s1 = Math.sin(dLat / 2), s2 = Math.sin(dLon / 2); const q = s1 * s1 + Math.cos(toRad(a[0])) * Math.cos(toRad(b[0])) * s2 * s2; return 2 * R * Math.asin(Math.sqrt(q)); }
}

const app = new TrafficAnalyzer();
app.init();

</script>
</body>
</html>

