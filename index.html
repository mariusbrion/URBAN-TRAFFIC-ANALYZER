<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Urban Traffic Analyzer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            overflow: hidden;
        }
        
        #map {
            height: 100vh;
            width: 100%;
        }
        
        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 300px;
        }
        
        .control-panel h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        
        .instructions {
            padding: 10px;
            background: #E3F2FD;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 13px;
            color: #1976D2;
        }
        
        .btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        .btn:hover {
            background: #45a049;
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .btn-clear {
            background: #f44336;
        }
        
        .btn-clear:hover {
            background: #da190b;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
            font-size: 12px;
            color: #666;
        }
        
        .legend {
            margin-top: 15px;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-color {
            width: 30px;
            height: 3px;
            margin-right: 10px;
        }
        
        .loading {
            text-align: center;
            color: #4CAF50;
            font-weight: bold;
        }
        
        .street-popup {
            font-size: 13px;
        }
        
        .street-popup strong {
            color: #333;
        }
        
        .close-btn {
            background: #000;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 8px;
            width: 100%;
            font-size: 12px;
        }
        
        .close-btn:hover {
            background: #333;
        }
        
        .close-btn.reopen {
            background: #4CAF50;
        }
        
        .close-btn.reopen:hover {
            background: #45a049;
        }
        
        .closed-street {
            animation: flash 1s ease-in-out;
        }
        
        @keyframes flash {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        .alternative-route {
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        .stats {
            margin-top: 10px;
            padding: 10px;
            background: #E8F5E9;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .stats div {
            margin: 3px 0;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="control-panel">
        <h3>üö¶ Traffic Analyzer</h3>
        
        <div class="instructions">
            üìç Draw a polygon on the map to select an area, then click "Load Streets"
        </div>
        
        <button id="loadStreetsBtn" class="btn" disabled>Load Street Network</button>
        
        <div style="margin-top: 15px;">
            <label style="font-size: 13px; color: #666; display: block; margin-bottom: 5px;">
                <strong>Traffic Period:</strong>
            </label>
            <select id="timePeriodSelect" class="btn" style="padding: 8px;" disabled>
                <option value="">Select period...</option>
                <option value="morning">Morning Rush (7-9 AM)</option>
                <option value="evening">Evening Rush (5-7 PM)</option>
                <option value="offpeak">Off-Peak (2-4 PM)</option>
            </select>
        </div>
        
        <button id="calculateImportanceBtn" class="btn" style="background: #9C27B0; margin-top: 10px;" disabled>Calculate Importance</button>
        
        <div style="margin-top: 15px;">
            <label style="font-size: 13px; color: #666; display: block; margin-bottom: 5px;">
                <strong>View Mode:</strong>
            </label>
            <select id="viewModeSelect" class="btn" style="padding: 8px;" disabled>
                <option value="roadtype">Road Types</option>
                <option value="traffic">Traffic Flow</option>
                <option value="importance">Street Importance</option>
            </select>
        </div>
        
        <div style="margin-top: 15px; padding: 10px; background: #FFF3CD; border-radius: 4px; font-size: 12px;">
            <strong>üöß Simulation Mode:</strong>
            <div style="margin-top: 5px;">Click streets to close/open them</div>
        </div>
        
        <button id="resetSimulationBtn" class="btn" style="background: #FF9800; margin-top: 10px;" disabled>Reset Closures</button>
        
        <button id="clearBtn" class="btn btn-clear">Clear All</button>
        
        <div id="status" class="status">Draw a polygon to get started</div>
        
        <div id="stats" class="stats" style="display: none;">
            <strong>Network Stats:</strong>
            <div id="nodeCount">Nodes: 0</div>
            <div id="edgeCount">Streets: 0</div>
        </div>
        
        <div class="legend">
            <strong id="legendTitle">Road Types:</strong>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF4444;"></div>
                <span id="legend1">Motorway</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF8800;"></div>
                <span id="legend2">Primary</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFB700;"></div>
                <span id="legend3">Secondary</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4CAF50;"></div>
                <span id="legend4">Residential</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #888888;"></div>
                <span id="legend5">Other</span>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <script src="https://unpkg.com/graphology/dist/graphology.umd.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    
    <script>
        class TrafficAnalyzer {
            constructor() {
                this.map = null;
                this.graph = new graphology.Graph();
                this.streetLayers = {};
                this.osmData = null;
                this.drawnItems = null;
                this.selectedPolygon = null;
                this.tomtomApiKey = '2hRMy8jfLxTGLUhZ3UJNoqAlihmLd9PA';
                this.currentViewMode = 'roadtype'; // 'roadtype' or 'traffic' or 'importance'
                this.trafficData = {};
                this.importanceScores = {};
                this.closedStreets = new Set();
                this.originalGraph = null;
                
                // Default city: Bordeaux, France
                this.defaultCenter = [44.8378, -0.5792];
                this.defaultZoom = 14;
            }
            
            async initialize() {
                this.setupMap();
                this.setupDrawControls();
                this.setupEventHandlers();
                this.updateStatus('Draw a polygon on the map to select an area');
            }
            
            setupMap() {
                // Initialize Leaflet map
                this.map = L.map('map').setView(this.defaultCenter, this.defaultZoom);
                
                // Add OpenStreetMap base layer
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(this.map);
                
                console.log('Map initialized');
            }
            
            setupDrawControls() {
                // Layer for drawn items
                this.drawnItems = new L.FeatureGroup();
                this.map.addLayer(this.drawnItems);
                
                // Draw control
                const drawControl = new L.Control.Draw({
                    draw: {
                        polygon: {
                            shapeOptions: {
                                color: '#2196F3',
                                fillOpacity: 0.2
                            }
                        },
                        polyline: false,
                        rectangle: {
                            shapeOptions: {
                                color: '#2196F3',
                                fillOpacity: 0.2
                            }
                        },
                        circle: false,
                        marker: false,
                        circlemarker: false
                    },
                    edit: {
                        featureGroup: this.drawnItems,
                        remove: true
                    }
                });
                this.map.addControl(drawControl);
                
                // Event handlers for drawing
                this.map.on(L.Draw.Event.CREATED, (e) => {
                    const layer = e.layer;
                    this.drawnItems.addLayer(layer);
                    this.selectedPolygon = layer;
                    
                    document.getElementById('loadStreetsBtn').disabled = false;
                    this.updateStatus('Polygon drawn! Click "Load Street Network" to fetch data');
                });
                
                this.map.on(L.Draw.Event.DELETED, (e) => {
                    this.selectedPolygon = null;
                    document.getElementById('loadStreetsBtn').disabled = true;
                    this.updateStatus('Draw a polygon to select an area');
                });
            }
            
            setupEventHandlers() {
                document.getElementById('loadStreetsBtn').addEventListener('click', () => {
                    this.loadOSMData();
                });
                
                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.clearAll();
                });
                
                document.getElementById('timePeriodSelect').addEventListener('change', (e) => {
                    if (e.target.value) {
                        this.loadTrafficSnapshot(e.target.value);
                    }
                });
                
                document.getElementById('calculateImportanceBtn').addEventListener('click', () => {
                    this.calculateStreetImportance();
                });
                
                document.getElementById('viewModeSelect').addEventListener('change', (e) => {
                    this.toggleViewMode(e.target.value);
                });
                
                document.getElementById('resetSimulationBtn').addEventListener('click', () => {
                    this.resetSimulation();
                });
            }
            
            clearAll() {
                // Clear drawn items
                this.drawnItems.clearLayers();
                this.selectedPolygon = null;
                
                // Clear streets
                Object.values(this.streetLayers).forEach(layer => {
                    this.map.removeLayer(layer);
                });
                this.streetLayers = {};
                
                // Clear graph
                this.graph.clear();
                
                // Reset UI
                document.getElementById('loadStreetsBtn').disabled = true;
                document.getElementById('stats').style.display = 'none';
                this.updateStatus('Draw a polygon to select an area');
            }
            
            async loadOSMData() {
                if (!this.selectedPolygon) {
                    alert('Please draw a polygon first');
                    return;
                }
                
                const btn = document.getElementById('loadStreetsBtn');
                btn.disabled = true;
                this.updateStatus('Loading street network...', true);
                
                try {
                    // Get polygon coordinates
                    const latlngs = this.selectedPolygon.getLatLngs()[0];
                    const polyCoords = latlngs.map(ll => `${ll.lat} ${ll.lng}`).join(' ');
                    
                    // Overpass API query for streets within polygon
                    const query = `
                        [out:json][timeout:60];
                        (
                          way["highway"]["highway"!~"footway|path|cycleway|steps|pedestrian|service"](poly:"${polyCoords}");
                        );
                        out body;
                        >;
                        out skel qt;
                    `;
                    
                    console.log('Sending Overpass query...');
                    
                    const response = await axios.post(
                        'https://overpass-api.de/api/interpreter',
                        query,
                        { headers: { 'Content-Type': 'text/plain' } }
                    );
                    
                    this.osmData = response.data;
                    console.log('OSM data loaded:', this.osmData.elements.length, 'elements');
                    
                    if (this.osmData.elements.length === 0) {
                        this.updateStatus('No streets found in this area. Try a larger area.');
                        btn.disabled = false;
                        return;
                    }
                    
                    // Parse and visualize
                    this.parseOSMIntoGraph();
                    this.visualizeStreets();
                    
                    // Update stats
                    document.getElementById('stats').style.display = 'block';
                    document.getElementById('nodeCount').textContent = `Nodes: ${this.graph.order}`;
                    document.getElementById('edgeCount').textContent = `Streets: ${Object.keys(this.streetLayers).length}`;
                    
                    // Enable traffic selector and importance calculation
                    document.getElementById('timePeriodSelect').disabled = false;
                    document.getElementById('calculateImportanceBtn').disabled = false;
                    document.getElementById('viewModeSelect').disabled = false;
                    document.getElementById('resetSimulationBtn').disabled = false;
                    
                    // Save original graph for simulation resets
                    this.originalGraph = this.graph.copy();
                    
                    this.updateStatus(`‚úÖ Loaded ${Object.keys(this.streetLayers).length} street segments`);
                    btn.disabled = false;
                    
                } catch (error) {
                    console.error('Error loading OSM data:', error);
                    this.updateStatus('Error loading street data. Please try again.');
                    btn.disabled = false;
                }
            }
            
            parseOSMIntoGraph() {
                // Clear existing graph
                this.graph.clear();
                
                // First pass: collect all nodes
                const nodes = {};
                this.osmData.elements.forEach(element => {
                    if (element.type === 'node') {
                        nodes[element.id] = {
                            lat: element.lat,
                            lon: element.lon
                        };
                    }
                });
                
                console.log('Collected', Object.keys(nodes).length, 'nodes');
                
                // Second pass: process ways (streets)
                let edgeCount = 0;
                this.osmData.elements.forEach(element => {
                    if (element.type === 'way' && element.tags && element.tags.highway) {
                        const wayId = element.id;
                        const nodeIds = element.nodes;
                        
                        // Add nodes to graph if not already present
                        nodeIds.forEach(nodeId => {
                            if (!this.graph.hasNode(nodeId) && nodes[nodeId]) {
                                this.graph.addNode(nodeId, {
                                    lat: nodes[nodeId].lat,
                                    lon: nodes[nodeId].lon
                                });
                            }
                        });
                        
                        // Add edges between consecutive nodes
                        for (let i = 0; i < nodeIds.length - 1; i++) {
                            const source = nodeIds[i];
                            const target = nodeIds[i + 1];
                            
                            if (nodes[source] && nodes[target]) {
                                const edgeId = `${wayId}_${i}`;
                                
                                try {
                                    // Correct order: source, target, attributes
                                    this.graph.addEdge(source, target, {
                                        edgeId: edgeId,
                                        wayId: wayId,
                                        highway: element.tags.highway,
                                        name: element.tags.name || 'Unnamed',
                                        maxspeed: element.tags.maxspeed || 'Unknown',
                                        coordinates: [
                                            [nodes[source].lat, nodes[source].lon],
                                            [nodes[target].lat, nodes[target].lon]
                                        ]
                                    });
                                    edgeCount++;
                                } catch (e) {
                                    // Edge might already exist, skip
                                }
                            }
                        }
                    }
                });
                
                console.log('Graph built:', this.graph.order, 'nodes,', edgeCount, 'edges');
            }
            
            visualizeStreets() {
                // Clear existing street layers
                Object.values(this.streetLayers).forEach(layer => {
                    this.map.removeLayer(layer);
                });
                this.streetLayers = {};
                
                // Draw each edge
                let layerCount = 0;
                this.graph.forEachEdge((edge, attributes) => {
                    const coords = attributes.coordinates;
                    const color = this.getRoadColor(attributes.highway);
                    const weight = this.getRoadWeight(attributes.highway);
                    
                    const polyline = L.polyline(coords, {
                        color: color,
                        weight: weight,
                        opacity: 0.7
                    }).addTo(this.map);
                    
                    // Add popup with street info
                    const popupContent = `
                        <div class="street-popup">
                            <strong>${attributes.name}</strong><br>
                            Type: ${attributes.highway}<br>
                            Max Speed: ${attributes.maxspeed}<br>
                            Way ID: ${attributes.wayId}
                        </div>
                    `;
                    polyline.bindPopup(popupContent);
                    
                    this.streetLayers[attributes.edgeId] = polyline;
                    layerCount++;
                });
                
                console.log('Visualized', layerCount, 'street segments');
            }
            
            getRoadColor(highway) {
                const colors = {
                    'motorway': '#FF4444',
                    'motorway_link': '#FF4444',
                    'trunk': '#FF6644',
                    'trunk_link': '#FF6644',
                    'primary': '#FF8800',
                    'primary_link': '#FF8800',
                    'secondary': '#FFB700',
                    'secondary_link': '#FFB700',
                    'tertiary': '#FFDD00',
                    'residential': '#4CAF50',
                    'unclassified': '#999999',
                    'living_street': '#4CAF50'
                };
                
                return colors[highway] || '#888888';
            }
            
            getRoadWeight(highway) {
                const weights = {
                    'motorway': 4,
                    'motorway_link': 3,
                    'trunk': 4,
                    'trunk_link': 3,
                    'primary': 3,
                    'primary_link': 2,
                    'secondary': 2,
                    'secondary_link': 2,
                    'tertiary': 2,
                    'residential': 1.5,
                    'unclassified': 1.5
                };
                
                return weights[highway] || 1.5;
            }
            
            updateStatus(message, loading = false) {
                const statusDiv = document.getElementById('status');
                statusDiv.innerHTML = loading ? `<div class="loading">${message}</div>` : message;
            }
            
            async loadTrafficSnapshot(timePeriod) {
                this.updateStatus(`Loading ${timePeriod} traffic data...`, true);
                this.currentViewMode = 'traffic';
                this.trafficData = {};
                
                let successCount = 0;
                let totalStreets = 0;
                
                // Sample points from each street
                for (const [edgeId, layer] of Object.entries(this.streetLayers)) {
                    totalStreets++;
                    const coords = layer.getLatLngs();
                    const midPoint = coords[Math.floor(coords.length / 2)];
                    
                    try {
                        const response = await axios.get(
                            `https://api.tomtom.com/traffic/services/4/flowSegmentData/absolute/10/json`,
                            {
                                params: {
                                    key: this.tomtomApiKey,
                                    point: `${midPoint.lat},${midPoint.lng}`
                                }
                            }
                        );
                        
                        if (response.data.flowSegmentData) {
                            const flowData = response.data.flowSegmentData;
                            this.trafficData[edgeId] = {
                                currentSpeed: flowData.currentSpeed,
                                freeFlowSpeed: flowData.freeFlowSpeed,
                                confidence: flowData.confidence
                            };
                            
                            // Update graph edge
                            this.graph.forEachEdge((edge, attrs) => {
                                if (attrs.edgeId === edgeId) {
                                    this.graph.setEdgeAttribute(edge, 'traffic', this.trafficData[edgeId]);
                                }
                            });
                            
                            successCount++;
                        }
                    } catch (error) {
                        // Silent fail for individual streets
                    }
                    
                    // Update progress
                    if (totalStreets % 10 === 0) {
                        this.updateStatus(`Loading traffic: ${totalStreets}/${Object.keys(this.streetLayers).length}...`, true);
                    }
                }
                
                this.updateTrafficVisualization();
                this.updateLegendForTraffic();
                this.updateStatus(`‚úÖ Loaded traffic data (${successCount}/${totalStreets} streets)`);
            }
            
            updateTrafficVisualization() {
                for (const [edgeId, layer] of Object.entries(this.streetLayers)) {
                    const traffic = this.trafficData[edgeId];
                    
                    if (traffic) {
                        const congestion = this.calculateCongestion(traffic);
                        layer.setStyle({
                            color: congestion.color,
                            weight: 4,
                            opacity: 0.8
                        });
                        
                        // Update popup
                        const oldPopup = layer.getPopup();
                        if (oldPopup) {
                            const content = oldPopup.getContent() + `
                                <br><strong>Traffic:</strong>
                                <br>Current: ${traffic.currentSpeed} km/h
                                <br>Free Flow: ${traffic.freeFlowSpeed} km/h
                                <br>Congestion: ${congestion.percentage}%
                            `;
                            layer.setPopupContent(content);
                        }
                    }
                }
            }
            
            calculateCongestion(flowData) {
                const ratio = flowData.currentSpeed / flowData.freeFlowSpeed;
                const congestionPercent = Math.round((1 - ratio) * 100);
                
                let color;
                if (ratio > 0.8) color = '#22C55E'; // Free flow - green
                else if (ratio > 0.6) color = '#FACC15'; // Light - yellow
                else if (ratio > 0.4) color = '#FB923C'; // Moderate - orange
                else if (ratio > 0.2) color = '#EF4444'; // Heavy - red
                else color = '#991B1B'; // Severe - dark red
                
                return { color, percentage: Math.max(0, congestionPercent) };
            }
            
            updateLegendForTraffic() {
                document.getElementById('legendTitle').textContent = 'Traffic Levels:';
                document.getElementById('legend1').textContent = 'Free Flow';
                document.getElementById('legend2').textContent = 'Light';
                document.getElementById('legend3').textContent = 'Moderate';
                document.getElementById('legend4').textContent = 'Heavy';
                document.getElementById('legend5').textContent = 'Severe';
                
                document.querySelector('.legend-item:nth-child(2) .legend-color').style.background = '#22C55E';
                document.querySelector('.legend-item:nth-child(3) .legend-color').style.background = '#FACC15';
                document.querySelector('.legend-item:nth-child(4) .legend-color').style.background = '#FB923C';
                document.querySelector('.legend-item:nth-child(5) .legend-color').style.background = '#EF4444';
                document.querySelector('.legend-item:nth-child(6) .legend-color').style.background = '#991B1B';
            }
            
            calculateStreetImportance() {
                this.updateStatus('Calculating street importance...', true);
                
                // Set edge weights based on traffic (if available) or default
                this.graph.forEachEdge((edge, attrs) => {
                    const traffic = attrs.traffic;
                    let weight = 1;
                    
                    if (traffic) {
                        const speed = traffic.currentSpeed || 50;
                        const congestionFactor = traffic.freeFlowSpeed / Math.max(speed, 1);
                        weight = congestionFactor;
                    }
                    
                    this.graph.setEdgeAttribute(edge, 'weight', weight);
                });
                
                // Calculate betweenness centrality using simplified algorithm
                const centrality = this.calculateBetweenness();
                
                // Normalize scores 0-100
                const scores = Object.values(centrality);
                const maxScore = Math.max(...scores);
                const minScore = Math.min(...scores);
                const range = maxScore - minScore || 1;
                
                this.importanceScores = {};
                this.graph.forEachEdge((edge, attrs) => {
                    const sourceScore = centrality[this.graph.source(edge)] || 0;
                    const targetScore = centrality[this.graph.target(edge)] || 0;
                    const edgeScore = (sourceScore + targetScore) / 2;
                    const normalized = ((edgeScore - minScore) / range) * 100;
                    
                    this.importanceScores[attrs.edgeId] = Math.round(normalized);
                    this.graph.setEdgeAttribute(edge, 'importance', normalized);
                });
                
                this.updateStatus('‚úÖ Importance calculated! Switch to "Street Importance" view');
                document.getElementById('viewModeSelect').value = 'importance';
                this.toggleViewMode('importance');
            }
            
            calculateBetweenness() {
                const betweenness = {};
                const nodes = this.graph.nodes();
                
                // Initialize all nodes to 0
                nodes.forEach(node => betweenness[node] = 0);
                
                // For each node as source
                nodes.forEach(source => {
                    const stack = [];
                    const paths = {};
                    const dist = {};
                    const sigma = {};
                    const delta = {};
                    
                    nodes.forEach(node => {
                        paths[node] = [];
                        dist[node] = -1;
                        sigma[node] = 0;
                        delta[node] = 0;
                    });
                    
                    dist[source] = 0;
                    sigma[source] = 1;
                    const queue = [source];
                    
                    // BFS
                    while (queue.length > 0) {
                        const v = queue.shift();
                        stack.push(v);
                        
                        const neighbors = this.graph.neighbors(v);
                        neighbors.forEach(w => {
                            // First time we see this node?
                            if (dist[w] < 0) {
                                queue.push(w);
                                dist[w] = dist[v] + 1;
                            }
                            
                            // Shortest path to w via v?
                            if (dist[w] === dist[v] + 1) {
                                sigma[w] += sigma[v];
                                paths[w].push(v);
                            }
                        });
                    }
                    
                    // Accumulation
                    while (stack.length > 0) {
                        const w = stack.pop();
                        paths[w].forEach(v => {
                            delta[v] += (sigma[v] / sigma[w]) * (1 + delta[w]);
                        });
                        if (w !== source) {
                            betweenness[w] += delta[w];
                        }
                    }
                });
                
                return betweenness;
            }
            
            toggleViewMode(mode) {
                this.currentViewMode = mode;
                
                if (mode === 'roadtype') {
                    this.visualizeByRoadType();
                    this.updateLegendForRoadType();
                } else if (mode === 'traffic') {
                    if (Object.keys(this.trafficData).length > 0) {
                        this.updateTrafficVisualization();
                        this.updateLegendForTraffic();
                    } else {
                        alert('Please load traffic data first');
                        document.getElementById('viewModeSelect').value = 'roadtype';
                    }
                } else if (mode === 'importance') {
                    if (Object.keys(this.importanceScores).length > 0) {
                        this.visualizeImportance();
                        this.updateLegendForImportance();
                    } else {
                        alert('Please calculate importance first');
                        document.getElementById('viewModeSelect').value = 'roadtype';
                    }
                }
            }
            
            visualizeByRoadType() {
                this.graph.forEachEdge((edge, attrs) => {
                    const layer = this.streetLayers[attrs.edgeId];
                    if (layer) {
                        layer.setStyle({
                            color: this.getRoadColor(attrs.highway),
                            weight: this.getRoadWeight(attrs.highway),
                            opacity: 0.7
                        });
                    }
                });
            }
            
            visualizeImportance() {
                for (const [edgeId, layer] of Object.entries(this.streetLayers)) {
                    const score = this.importanceScores[edgeId] || 0;
                    const color = this.getImportanceColor(score);
                    
                    layer.setStyle({
                        color: color,
                        weight: 3 + (score / 25), // Thicker for more important
                        opacity: 0.8
                    });
                    
                    // Update popup
                    this.graph.forEachEdge((edge, attrs) => {
                        if (attrs.edgeId === edgeId) {
                            const popup = layer.getPopup();
                            if (popup) {
                                const baseContent = popup.getContent().split('<br><strong>Traffic:')[0];
                                layer.setPopupContent(baseContent + `
                                    <br><strong>Importance Score: ${score}/100</strong>
                                    <br>Rank: ${this.getImportanceRank(score)}
                                `);
                            }
                        }
                    });
                }
            }
            
            getImportanceColor(score) {
                // Gradient from blue (low) to red (high)
                if (score > 80) return '#DC2626'; // Critical
                if (score > 60) return '#F97316'; // Very important
                if (score > 40) return '#FACC15'; // Important
                if (score > 20) return '#4ADE80'; // Moderate
                return '#60A5FA'; // Low importance
            }
            
            getImportanceRank(score) {
                if (score > 80) return 'Critical';
                if (score > 60) return 'Very Important';
                if (score > 40) return 'Important';
                if (score > 20) return 'Moderate';
                return 'Low';
            }
            
            updateLegendForRoadType() {
                document.getElementById('legendTitle').textContent = 'Road Types:';
                document.getElementById('legend1').textContent = 'Motorway';
                document.getElementById('legend2').textContent = 'Primary';
                document.getElementById('legend3').textContent = 'Secondary';
                document.getElementById('legend4').textContent = 'Residential';
                document.getElementById('legend5').textContent = 'Other';
                
                document.querySelector('.legend-item:nth-child(2) .legend-color').style.background = '#FF4444';
                document.querySelector('.legend-item:nth-child(3) .legend-color').style.background = '#FF8800';
                document.querySelector('.legend-item:nth-child(4) .legend-color').style.background = '#FFB700';
                document.querySelector('.legend-item:nth-child(5) .legend-color').style.background = '#4CAF50';
                document.querySelector('.legend-item:nth-child(6) .legend-color').style.background = '#888888';
            }
            
            updateLegendForImportance() {
                document.getElementById('legendTitle').textContent = 'Importance:';
                document.getElementById('legend1').textContent = 'Critical (80-100)';
                document.getElementById('legend2').textContent = 'Very Important (60-80)';
                document.getElementById('legend3').textContent = 'Important (40-60)';
                document.getElementById('legend4').textContent = 'Moderate (20-40)';
                document.getElementById('legend5').textContent = 'Low (0-20)';
                
                document.querySelector('.legend-item:nth-child(2) .legend-color').style.background = '#DC2626';
                document.querySelector('.legend-item:nth-child(3) .legend-color').style.background = '#F97316';
                document.querySelector('.legend-item:nth-child(4) .legend-color').style.background = '#FACC15';
                document.querySelector('.legend-item:nth-child(5) .legend-color').style.background = '#4ADE80';
                document.querySelector('.legend-item:nth-child(6) .legend-color').style.background = '#60A5FA';
            }
            
            simulateStreetClosure(edgeId) {
                const layer = this.streetLayers[edgeId];
                if (!layer) return;
                
                // Toggle closure
                if (this.closedStreets.has(edgeId)) {
                    // Reopen street
                    this.closedStreets.delete(edgeId);
                    layer.setStyle({ 
                        opacity: 0.7,
                        dashArray: null,
                        className: ''
                    });
                    
                    // Re-add edge to graph
                    this.graph.forEachEdge((edge, attrs) => {
                        if (attrs.edgeId === edgeId && this.originalGraph.hasEdge(edge)) {
                            const origAttrs = this.originalGraph.getEdgeAttributes(edge);
                            Object.keys(origAttrs).forEach(key => {
                                this.graph.setEdgeAttribute(edge, key, origAttrs[key]);
                            });
                        }
                    });
                    
                    this.updatePopupButton(edgeId, false);
                    this.updateStatus(`Street reopened. ${this.closedStreets.size} streets closed.`);
                } else {
                    // Close street
                    this.closedStreets.add(edgeId);
                    layer.setStyle({ 
                        color: '#000000',
                        opacity: 0.5,
                        dashArray: '10, 10',
                        weight: 5,
                        className: 'closed-street'
                    });
                    
                    // Find edge in graph and get traffic
                    let closedEdge = null;
                    let closedTraffic = 0;
                    this.graph.forEachEdge((edge, attrs) => {
                        if (attrs.edgeId === edgeId) {
                            closedEdge = edge;
                            closedTraffic = attrs.traffic ? 
                                (attrs.traffic.freeFlowSpeed / Math.max(attrs.traffic.currentSpeed, 1)) : 1;
                        }
                    });
                    
                    if (closedEdge) {
                        const source = this.graph.source(closedEdge);
                        const target = this.graph.target(closedEdge);
                        
                        // Remove edge temporarily
                        this.graph.dropEdge(closedEdge);
                        
                        // Find alternative routes
                        const alternatives = this.findAlternativeRoutes(source, target);
                        
                        // Redistribute traffic
                        if (alternatives.length > 0) {
                            this.estimateTrafficRedistribution(closedTraffic, alternatives);
                            this.visualizeClosureImpact(alternatives);
                        }
                    }
                    
                    this.updatePopupButton(edgeId, true);
                    this.updateStatus(`üöß Street closed! ${this.closedStreets.size} total closures. Finding alternatives...`);
                }
                
                // Close popup after action
                layer.closePopup();
            }
            
            updatePopupButton(edgeId, isClosed) {
                const layer = this.streetLayers[edgeId];
                if (!layer) return;
                
                const popup = layer.getPopup();
                if (popup) {
                    const content = popup.getContent();
                    const buttonText = isClosed ? '‚úÖ Reopen Street' : 'üöß Close Street';
                    const buttonClass = isClosed ? 'close-btn reopen' : 'close-btn';
                    
                    const newContent = content.replace(
                        /<button class="close-btn[^"]*"[^>]*>.*?<\/button>/,
                        `<button class="${buttonClass}" onclick="analyzer.simulateStreetClosure('${edgeId}'); return false;">${buttonText}</button>`
                    );
                    popup.setContent(newContent);
                }
            }
            
            findAlternativeRoutes(source, target) {
                // BFS to find alternative paths
                const queue = [[source]];
                const visited = new Set([source]);
                const alternatives = [];
                const maxPaths = 3;
                
                while (queue.length > 0 && alternatives.length < maxPaths) {
                    const path = queue.shift();
                    const current = path[path.length - 1];
                    
                    if (current === target && path.length > 1) {
                        // Found alternative path
                        const edges = [];
                        for (let i = 0; i < path.length - 1; i++) {
                            const edge = this.graph.edge(path[i], path[i + 1]);
                            if (edge) edges.push(edge);
                        }
                        alternatives.push({ path, edges });
                        continue;
                    }
                    
                    if (path.length > 5) continue; // Limit path length
                    
                    const neighbors = this.graph.neighbors(current);
                    for (const neighbor of neighbors) {
                        if (!path.includes(neighbor)) {
                            queue.push([...path, neighbor]);
                        }
                    }
                }
                
                return alternatives;
            }
            
            estimateTrafficRedistribution(closedTraffic, alternatives) {
                if (alternatives.length === 0) return;
                
                // Distribute traffic proportionally to alternative routes
                const trafficPerRoute = closedTraffic / alternatives.length;
                
                alternatives.forEach(alt => {
                    alt.edges.forEach(edge => {
                        const attrs = this.graph.getEdgeAttributes(edge);
                        const currentWeight = attrs.weight || 1;
                        const newWeight = currentWeight + (trafficPerRoute * 0.5);
                        
                        this.graph.setEdgeAttribute(edge, 'weight', newWeight);
                        this.graph.setEdgeAttribute(edge, 'redistributed', true);
                    });
                });
            }
            
            visualizeClosureImpact(alternatives) {
                // Highlight alternative routes
                alternatives.forEach((alt, index) => {
                    alt.edges.forEach(edge => {
                        const attrs = this.graph.getEdgeAttributes(edge);
                        const layer = this.streetLayers[attrs.edgeId];
                        
                        if (layer && !this.closedStreets.has(attrs.edgeId)) {
                            // Animate alternative routes
                            setTimeout(() => {
                                layer.setStyle({
                                    color: '#FF6B6B',
                                    weight: 5,
                                    opacity: 0.9,
                                    className: 'alternative-route'
                                });
                            }, index * 200);
                            
                            // Reset after animation
                            setTimeout(() => {
                                if (!this.closedStreets.has(attrs.edgeId)) {
                                    const color = this.currentViewMode === 'importance' 
                                        ? this.getImportanceColor(this.importanceScores[attrs.edgeId] || 0)
                                        : this.getRoadColor(attrs.highway);
                                    layer.setStyle({
                                        color: color,
                                        weight: 4,
                                        opacity: 0.8,
                                        className: ''
                                    });
                                }
                            }, 3000 + index * 200);
                        }
                    });
                });
            }
            
            resetSimulation() {
                // Reopen all streets
                this.closedStreets.forEach(edgeId => {
                    const layer = this.streetLayers[edgeId];
                    if (layer) {
                        layer.setStyle({ 
                            opacity: 0.7,
                            dashArray: null,
                            className: ''
                        });
                    }
                });
                
                this.closedStreets.clear();
                
                // Restore original graph
                if (this.originalGraph) {
                    this.graph = this.originalGraph.copy();
                }
                
                // Refresh visualization
                this.toggleViewMode(this.currentViewMode);
                this.updateStatus('‚úÖ All closures reset');
            }
        }
        
        // Initialize the application
        const analyzer = new TrafficAnalyzer();
        analyzer.initialize();
    </script>
</body>
</html>
