<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Urban Traffic Analyzer (Concise)</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
<style>
  *{box-sizing:border-box}body{margin:0;font-family:system-ui,Segoe UI,Arial;height:100vh;overflow:hidden}
  #map{height:100vh}
  .panel{position:absolute;top:16px;right:16px;background:#fff;padding:16px;border-radius:8px;box-shadow:0 2px 12px rgba(0,0,0,.15);z-index:1000;width:300px;max-height:90vh;overflow:auto}
  .panel h3{margin:0 0 8px}
  .panel .hint{font-size:12px;background:#E3F2FD;color:#1976D2;padding:8px;border-radius:4px;margin-bottom:8px}
  .btn, select{width:100%;padding:10px;margin:6px 0;border:none;border-radius:6px;background:#4CAF50;color:#fff;cursor:pointer}
  .btn:disabled{background:#ccc;cursor:not-allowed}
  .btn.secondary{background:#000}
  .btn.warn{background:#FF9800}
  .btn.danger{background:#f44336}
  .status{background:#f7f7f7;padding:8px;border-radius:4px;font-size:12px;margin-top:8px}
  .legend{margin-top:10px;background:#f9f9f9;padding:8px;border-radius:4px;font-size:12px}
  .legend-item{display:flex;align-items:center;margin:4px 0}
  .legend-color{width:30px;height:3px;margin-right:8px}
  .stats{margin-top:8px;background:#E8F5E9;padding:8px;border-radius:4px;font-size:12px}
  .street-popup{font-size:12px}
  .alt{animation:pulse 1.8s ease-in-out infinite}
  @keyframes pulse{0%,100%{opacity:.6}50%{opacity:1}}
</style>
</head>
<body>
<div id="map"></div>

<div class="panel">
  <h3>üö¶ Traffic Analyzer</h3>
  <div class="hint">Draw a polygon on the map, then click ‚ÄúLoad Street Network‚Äù.</div>

  <button id="btnLoad" class="btn" disabled>Load Street Network</button>

  <label style="font-size:12px;color:#555;margin-top:6px">Traffic Period</label>
  <select id="selPeriod" disabled>
    <option value="">Select period‚Ä¶</option>
    <option value="morning">Morning Rush (7-9)</option>
    <option value="evening">Evening Rush (5-7)</option>
    <option value="offpeak">Off-Peak (2-4)</option>
  </select>

  <button id="btnImportance" class="btn" style="background:#9C27B0" disabled>Calculate Importance</button>

  <label style="font-size:12px;color:#555;margin-top:6px">View Mode</label>
  <select id="selView" disabled>
    <option value="roadtype">Road Types</option>
    <option value="traffic">Traffic Flow</option>
    <option value="importance">Street Importance</option>
  </select>

  <div style="margin-top:10px;background:#FFF3CD;padding:8px;border-radius:6px;font-size:12px">
    <strong>üöß Simulation:</strong>
    <div>Click ‚ÄúClose/Reopen a Street‚Äù, then click a street on the map.</div>
    <button id="btnCloseMode" class="btn secondary" disabled>Close/Reopen a Street</button>
  </div>

  <button id="btnReset" class="btn warn" disabled>Reset Closures</button>
  <button id="btnClear" class="btn danger">Clear All</button>

  <div id="status" class="status">Draw a polygon to get started.</div>
  <div id="stats" class="stats" style="display:none">
    <strong>Network Stats</strong>
    <div id="nodes">Nodes: 0</div>
    <div id="ways">Streets: 0</div>
  </div>

  <div class="legend">
    <strong id="lgTitle">Road Types:</strong>
    <div class="legend-item"><div class="legend-color" id="lg1" style="background:#FF4444"></div>Motorway</div>
    <div class="legend-item"><div class="legend-color" id="lg2" style="background:#FF8800"></div>Primary</div>
    <div class="legend-item"><div class="legend-color" id="lg3" style="background:#FFB700"></div>Secondary</div>
    <div class="legend-item"><div class="legend-color" id="lg4" style="background:#4CAF50"></div>Residential</div>
    <div class="legend-item"><div class="legend-color" id="lg5" style="background:#888"></div>Other</div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script src="https://unpkg.com/graphology/dist/graphology.umd.js"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>

<script>
class TrafficAnalyzer {
  constructor() {
    this.map=null; this.drawn=null; this.poly=null;
    this.graph=new graphology.Graph({type:'directed'}); // two-way ways get both dirs
    this.originalGraph=null;

    this.nodesById={};        // osm nodeId -> {lat,lon}
    this.ways={};             // wayId -> {name,highway,maxspeed,coords:[latlng],nodeIds:[]}
    this.edgesByWay={};       // wayId -> [edgeKeys]
    this.layers={};           // wayId -> Leaflet Polyline
    this.closedWays=new Set();
    this.trafficByWay={};     // wayId -> {current,free,confidence}
    this.importanceByWay={};  // wayId -> 0..100

    this.closeMode=false;
    this.viewMode='roadtype';
    this.tomtom='2hRMy8jfLxTGLUhZ3UJNoqAlihmLd9PA';
    this.center=[44.8378,-0.5792]; this.zoom=14;
  }

  async init(){
    this.map=L.map('map').setView(this.center,this.zoom);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'¬© OpenStreetMap'}).addTo(this.map);

    this.drawn=new L.FeatureGroup().addTo(this.map);
    const drawCtl=new L.Control.Draw({
      draw:{polygon:{shapeOptions:{color:'#2196F3',fillOpacity:.2}},rectangle:{shapeOptions:{color:'#2196F3',fillOpacity:.2}},polyline:false,marker:false,circle:false,circlemarker:false},
      edit:{featureGroup:this.drawn,remove:true}
    }); this.map.addControl(drawCtl);

    this.map.on(L.Draw.Event.CREATED,(e)=>{ this.drawn.clearLayers(); this.poly=e.layer; this.drawn.addLayer(this.poly); Q('#btnLoad').disabled=false; this.status('Polygon ready. Click ‚ÄúLoad Street Network‚Äù.'); });
    this.map.on(L.Draw.Event.DELETED,()=>{ this.poly=null; Q('#btnLoad').disabled=true; this.status('Draw a polygon to get started.'); });

    Q('#btnLoad').onclick=()=>this.loadOSM();
    Q('#btnClear').onclick=()=>this.clearAll();
    Q('#selPeriod').onchange=(e)=>e.target.value&&this.loadTraffic(e.target.value);
    Q('#btnImportance').onclick=()=>this.calcImportance();
    Q('#selView').onchange=(e)=>this.setView(e.target.value);
    Q('#btnReset').onclick=()=>this.resetClosures();
    Q('#btnCloseMode').onclick=()=>this.toggleCloseMode(true);

    this.status('Draw a polygon to get started.');
  }

  status(msg,loading=false){ Q('#status').innerHTML=loading?`<b style="color:#4CAF50">${msg}</b>`:msg; }
  roadColor(h){ const c={motorway:'#FF4444',motorway_link:'#FF4444',trunk:'#FF6644',trunk_link:'#FF6644',primary:'#FF8800',primary_link:'#FF8800',secondary:'#FFB700',secondary_link:'#FFB700',tertiary:'#FFDD00',residential:'#4CAF50',living_street:'#4CAF50',unclassified:'#999'}; return c[h]||'#888'; }
  roadWeight(h){ const w={motorway:4,trunk:4,primary:3,secondary:2,tertiary:2,residential:1.8,unclassified:1.6}; return w[h]||1.6; }
  congestionColor(r){ return r>0.8?'#22C55E':r>0.6?'#FACC15':r>0.4?'#FB923C':r>0.2?'#EF4444':'#991B1B'; }
  importanceColor(s){ return s>80?'#DC2626':s>60?'#F97316':s>40?'#FACC15':s>20?'#4ADE80':'#60A5FA'; }

  async loadOSM(){
    if(!this.poly) return alert('Draw polygon first.');
    this.resetState(true);
    this.status('Loading street network‚Ä¶',true); Q('#btnLoad').disabled=true;

    const latlngs=this.poly.getLatLngs()[0]; if(!latlngs||!latlngs.length){ this.status('Invalid polygon.'); Q('#btnLoad').disabled=false; return; }
    const polyStr=latlngs.map(ll=>`${ll.lat} ${ll.lng}`).join(' ');
    const query=`[out:json][timeout:60];
      (way["highway"]["highway"!~"footway|path|cycleway|steps|pedestrian|service"](poly:"${polyStr}"););
      out body;>;out skel qt;`;

    try{
      const {data}=await axios.post('https://overpass-api.de/api/interpreter',query,{headers:{'Content-Type':'text/plain'}});
      const elements=data.elements||[];
      elements.forEach(e=>{ if(e.type==='node') this.nodesById[e.id]={lat:e.lat,lon:e.lon}; });
      elements.forEach(e=>{
        if(e.type==='way'&&e.tags&&e.tags.highway&&e.nodes?.length>1){
          const coords=e.nodes.map(id=>this.nodesById[id]).filter(Boolean).map(n=>[n.lat,n.lon]);
          if(coords.length<2) return;
          this.ways[e.id]={wayId:e.id,name:e.tags.name||'Unnamed',highway:e.tags.highway,maxspeed:e.tags.maxspeed||'Unknown',coords, nodeIds:e.nodes.slice()};
        }
      });
      if(!Object.keys(this.ways).length){ this.status('No streets found. Try a larger area.'); Q('#btnLoad').disabled=false; return; }

      this.buildCompressedGraph(); this.drawWays();
      this.originalGraph=this.graph.copy();

      Q('#stats').style.display='block';
      Q('#nodes').textContent=`Nodes: ${this.graph.order}`;
      Q('#ways').textContent=`Streets: ${Object.keys(this.ways).length}`;

      ['#selPeriod','#btnImportance','#selView','#btnReset','#btnCloseMode'].forEach(s=>Q(s).disabled=false);
      this.status(`‚úÖ Loaded ${Object.keys(this.ways).length} streets`); Q('#btnLoad').disabled=false;
    }catch(e){ console.error(e); this.status('Error loading street data. Try again.'); Q('#btnLoad').disabled=false; }
  }

  buildCompressedGraph(){
    this.graph.clear(); this.edgesByWay={};
    // degree map (count neighbors across all ways)
    const deg={};
    Object.values(this.ways).forEach(w=>{
      for(let i=0;i<w.nodeIds.length-1;i++){
        const a=w.nodeIds[i], b=w.nodeIds[i+1];
        deg[a]=(deg[a]||0)+1; deg[b]=(deg[b]||0)+1;
      }
    });

    // add node if needed
    const addNode=(id)=>{ if(!this.graph.hasNode(id)){ const n=this.nodesById[id]; if(n) this.graph.addNode(id,{lat:n.lat,lon:n.lon}); } };

    // compress along degree-2 chains
    Object.values(this.ways).forEach(w=>{
      this.edgesByWay[w.wayId]=[];
      const N=w.nodeIds.length; let i=0, seg=0;
      while(i<N-1){
        let j=i+1; while(j<N-1 && (deg[w.nodeIds[j]]||0)===2) j++;
        const start=w.nodeIds[i], end=w.nodeIds[j];
        addNode(start); addNode(end);

        // polyline coords for this compressed segment
        const segCoords=[];
        for(let k=i;k<=j;k++){ const n=this.nodesById[w.nodeIds[k]]; if(n) segCoords.push([n.lat,n.lon]); }

        // add both directions unless oneway=yes
        const oneway=(w.oneway==='yes'||w.oneway===true||w.oneway===1||w.highway?.includes('_link'));
        const base={wayId:w.wayId,highway:w.highway,name:w.name,maxspeed:w.maxspeed,coords:segCoords};

        const keyF=`${w.wayId}:${seg}:f`, keyB=`${w.wayId}:${seg}:b`;
        this.graph.addEdgeWithKey(keyF,start,end,base);
        if(!oneway) this.graph.addEdgeWithKey(keyB,end,start,base);
        this.edgesByWay[w.wayId].push(keyF); if(!oneway) this.edgesByWay[w.wayId].push(keyB);
        seg++; i=j;
      }
    });
  }

  drawWays(){
    Object.values(this.layers).forEach(l=>this.map.removeLayer(l)); this.layers={};
    Object.values(this.ways).forEach(w=>{
      const layer=L.polyline(w.coords,{color:this.roadColor(w.highway),weight:this.roadWeight(w.highway),opacity:.75}).addTo(this.map);
      layer.bindPopup(this.popupHTML(w));
      layer.on('click', (e)=> this.onWayClick(w.wayId, e));
      this.layers[w.wayId]=layer;
    });
    this.updateLegendRoad();
  }

  popupHTML(w, extra=''){
    return `<div class="street-popup"><strong>${esc(w.name)}</strong><br>Type: ${esc(w.highway)}<br>Max Speed: ${esc(w.maxspeed)}<br>Way ID: ${w.wayId}${extra}</div>`;
  }

  async loadTraffic(period){
    this.status(`Loading ${period} traffic‚Ä¶`,true);
    this.trafficByWay={};
    let done=0, total=Object.keys(this.ways).length, ok=0;

    for(const w of Object.values(this.ways)){
      const mid=w.coords[Math.floor(w.coords.length/2)];
      try{
        const url='https://api.tomtom.com/traffic/services/4/flowSegmentData/absolute/10/json';
        const {data}=await axios.get(url,{params:{key:this.tomtom,point:`${mid[0]},${mid[1]}`}}); // sequential -> gentle on API
        if(data?.flowSegmentData){
          const f=data.flowSegmentData;
          this.trafficByWay[w.wayId]={current:f.currentSpeed,free:f.freeFlowSpeed,confidence:f.confidence};
          ok++;
        }
      }catch(e){}
      done++; if(done%10===0) this.status(`Traffic: ${done}/${total}‚Ä¶`,true);
    }
    if(this.viewMode!=='traffic'){ Q('#selView').value='traffic'; this.viewMode='traffic'; }
    this.renderTraffic(); this.updateLegendTraffic();
    this.status(`‚úÖ Traffic loaded (${ok}/${total})`);
  }

  renderTraffic(){
    for(const [wayId, layer] of Object.entries(this.layers)){
      const w=this.ways[wayId]; const t=this.trafficByWay[wayId];
      if(!w||!layer) continue;
      if(t){
        const ratio = Math.max(0.01, t.current / Math.max(1, t.free));
        layer.setStyle({color:this.congestionColor(ratio),weight:4,opacity:.9});
        layer.setPopupContent(this.popupHTML(w, `<br><strong>Traffic</strong><br>Current: ${t.current} km/h<br>Free: ${t.free} km/h<br>Congestion: ${Math.round((1-ratio)*100)}%`));
      } else {
        layer.setStyle({color:'#bbb',weight:3,opacity:.6});
      }
    }
  }

  calcImportance(){
    this.status('Calculating importance‚Ä¶',true);
    // Unweighted betweenness (Brandes simplified, directed graph)
    const nodes=this.graph.nodes(); const B={}; nodes.forEach(n=>B[n]=0);
    nodes.forEach(s=>{
      const S=[], P={}, sigma={}, dist={};
      nodes.forEach(n=>{P[n]=[];sigma[n]=0;dist[n]=-1;});
      sigma[s]=1; dist[s]=0;
      const Q=[s];
      while(Q.length){
        const v=Q.shift(); S.push(v);
        this.graph.outNeighbors(v).forEach(w=>{
          if(dist[w]<0){ Q.push(w); dist[w]=dist[v]+1; }
          if(dist[w]===dist[v]+1){ sigma[w]+=sigma[v]; P[w].push(v); }
        });
      }
      const delta={}; nodes.forEach(n=>delta[n]=0);
      while(S.length){
        const w=S.pop();
        P[w].forEach(v=>{ delta[v]+= (sigma[v]/Math.max(1,sigma[w]))*(1+delta[w]); });
        if(w!==s) B[w]+=delta[w];
      }
    });

    // Aggregate to ways: average of src/target centrality across that way‚Äôs edges, then normalize
    const wayScores={}; const vals=[];
    Object.entries(this.edgesByWay).forEach(([wayId,edgeKeys])=>{
      let sum=0, cnt=0;
      edgeKeys.forEach(k=>{
        if(this.graph.hasEdge(k)){
          const u=this.graph.source(k), v=this.graph.target(k);
          sum += ((B[u]||0)+(B[v]||0))/2; cnt++;
        }
      });
      const s=cnt?sum/cnt:0; wayScores[wayId]=s; vals.push(s);
    });
    const min=Math.min(...vals,0), max=Math.max(...vals,1), rng=(max-min)||1;
    this.importanceByWay={}; Object.keys(wayScores).forEach(wid=>{
      this.importanceByWay[wid]=Math.round(((wayScores[wid]-min)/rng)*100);
    });

    this.viewMode='importance'; Q('#selView').value='importance';
    this.renderImportance(); this.updateLegendImportance();
    this.status('‚úÖ Importance calculated. Switch views anytime.');
  }

  renderImportance(){
    Object.entries(this.layers).forEach(([wid,layer])=>{
      const score=this.importanceByWay[wid]||0, w=this.ways[wid];
      layer.setStyle({color:this.importanceColor(score),weight:3+(score/25),opacity:.9});
      layer.setPopupContent(this.popupHTML(w, `<br><strong>Importance</strong><br>Score: ${score}/100 (${this.rank(score)})`));
    });
  }
  rank(s){ return s>80?'Critical':s>60?'Very Important':s>40?'Important':s>20?'Moderate':'Low'; }

  setView(mode){
    this.viewMode=mode;
    if(mode==='roadtype'){ this.drawWays(); this.updateLegendRoad(); }
    else if(mode==='traffic'){
      if(Object.keys(this.trafficByWay).length){ this.renderTraffic(); this.updateLegendTraffic(); }
      else { alert('Load traffic data first'); Q('#selView').value='roadtype'; this.viewMode='roadtype'; this.updateLegendRoad(); }
    }
    else if(mode==='importance'){
      if(Object.keys(this.importanceByWay).length){ this.renderImportance(); this.updateLegendImportance(); }
      else { alert('Calculate importance first'); Q('#selView').value='roadtype'; this.viewMode='roadtype'; this.updateLegendRoad(); }
    }
  }

  updateLegendRoad(){ Q('#lgTitle').textContent='Road Types:'; S('#lg1','#FF4444','Motorway'); S('#lg2','#FF8800','Primary'); S('#lg3','#FFB700','Secondary'); S('#lg4','#4CAF50','Residential'); S('#lg5','#888','Other'); }
  updateLegendTraffic(){ Q('#lgTitle').textContent='Traffic Levels:'; S('#lg1','#22C55E','Free Flow'); S('#lg2','#FACC15','Light'); S('#lg3','#FB923C','Moderate'); S('#lg4','#EF4444','Heavy'); S('#lg5','#991B1B','Severe'); }
  updateLegendImportance(){ Q('#lgTitle').textContent='Importance:'; S('#lg1','#DC2626','Critical (80-100)'); S('#lg2','#F97316','Very Important (60-80)'); S('#lg3','#FACC15','Important (40-60)'); S('#lg4','#4ADE80','Moderate (20-40)'); S('#lg5','#60A5FA','Low (0-20)'); }

  toggleCloseMode(forceArm){
    this.closeMode = forceArm ? !this.closeMode : this.closeMode;
    const b=Q('#btnCloseMode');
    if(this.closeMode){ b.textContent='Click a street on the map to toggle closure (Click again to cancel)'; this.status('Simulation: Click a street to close or reopen it.'); b.style.background='#444'; }
    else { b.textContent='Close/Reopen a Street'; this.status('Simulation mode off.'); b.style.background='#000'; }
  }

  onWayClick(wayId, e){
    if(!this.closeMode) return; // Only act in close-mode
    if(this.closedWays.has(wayId)) this.reopenWay(wayId);
    else this.closeWay(wayId);
  }

  closeWay(wayId){
    const layer=this.layers[wayId]; if(!layer) return;
    this.closedWays.add(wayId);
    layer.setStyle({color:'#000',opacity:.6,weight:5,dashArray:'10,8'});
    const el=layer.getElement?.(); if(el) el.classList.add('alt');

    // drop all edges of this way
    (this.edgesByWay[wayId]||[]).forEach(k=>{ if(this.graph.hasEdge(k)) this.graph.dropEdge(k); });

    // find alternatives between way endpoints (first and last node of the way)
    const w=this.ways[wayId];
    const s=w.nodeIds[0], t=w.nodeIds[w.nodeIds.length-1];
    const alts=this.findAlternatives(s,t,3);
    this.redistributeTraffic(alts);
    this.highlightAlternatives(alts);

    this.status(`üöß Closed: ${w.name}. Total closures: ${this.closedWays.size}. Click another street or turn off close mode.`);
  }

  reopenWay(wayId){
    const layer=this.layers[wayId]; if(!layer) return;
    this.closedWays.delete(wayId);
    const w=this.ways[wayId];
    // restore style according to current view
    if(this.viewMode==='traffic' && this.trafficByWay[wayId]){
      const t=this.trafficByWay[wayId];
      const ratio=Math.max(0.01,t.current/Math.max(1,t.free));
      layer.setStyle({color:this.congestionColor(ratio),weight:4,opacity:.9,dashArray:null});
    } else if(this.viewMode==='importance' && this.importanceByWay[wayId]!=null){
      const score=this.importanceByWay[wayId];
      layer.setStyle({color:this.importanceColor(score),weight:3+(score/25),opacity:.9,dashArray:null});
    } else {
      layer.setStyle({color:this.roadColor(w.highway),weight:this.roadWeight(w.highway),opacity:.75,dashArray:null});
    }
    const el=layer.getElement?.(); if(el) el.classList.remove('alt');

    // re-add edges of this way from originalGraph
    this.originalGraph.forEachEdge((key,attrs,src,tgt)=>{
      if(attrs.wayId===wayId && !this.graph.hasEdge(key)){ this.graph.addEdgeWithKey(key,src,tgt,attrs); }
    });
    this.status(`Reopened: ${w.name}. Total closures: ${this.closedWays.size}.`);
  }

  findAlternatives(source,target,maxPaths=3){
    const paths=[]; const q=[[source]]; const seen=new Set([source]); const MAXLEN=10;
    while(q.length && paths.length<maxPaths){
      const p=q.shift(); const v=p[p.length-1];
      if(v===target && p.length>1){ paths.push(p); continue; }
      if(p.length>MAXLEN) continue;
      this.graph.outNeighbors(v).forEach(n=>{
        if(!p.includes(n)) q.push([...p,n]);
      });
    }
    // convert to edge lists
    return paths.map(p=>{
      const edges=[]; for(let i=0;i<p.length-1;i++){ const k=this.graph.edge(p[i],p[i+1]); if(k) edges.push(k); }
      return edges;
    }).filter(e=>e.length);
  }

  redistributeTraffic(alts){
    if(!alts.length) return;
    // simplistic: increase weight on alt edges slightly
    alts.forEach(es=>{
      es.forEach(k=>{
        const w=(this.graph.getEdgeAttribute(k,'weight')||1)+0.5;
        this.graph.setEdgeAttribute(k,'weight',w);
      });
    });
  }

  highlightAlternatives(alts){
    // highlight by way polyline color briefly
    const highlighted=new Set();
    alts.forEach((es,i)=>{
      es.forEach(k=>{
        const a=this.graph.getEdgeAttributes(k); const wayId=a.wayId;
        if(wayId && this.layers[wayId] && !this.closedWays.has(wayId) && !highlighted.has(wayId)){
          highlighted.add(wayId);
          const layer=this.layers[wayId];
          const old=layer.options.color;
          setTimeout(()=>layer.setStyle({color:'#FF6B6B',weight:5,opacity:.95}), i*150);
          setTimeout(()=>{
            if(!this.closedWays.has(wayId)){
              if(this.viewMode==='importance' && this.importanceByWay[wayId]!=null){
                const score=this.importanceByWay[wayId];
                layer.setStyle({color:this.importanceColor(score),weight:3+(score/25),opacity:.9});
              } else if(this.viewMode==='traffic' && this.trafficByWay[wayId]){
                const t=this.trafficByWay[wayId]; const r=Math.max(0.01,t.current/Math.max(1,t.free));
                layer.setStyle({color:this.congestionColor(r),weight:4,opacity:.9});
              } else {
                const w=this.ways[wayId];
                layer.setStyle({color:this.roadColor(w.highway),weight:this.roadWeight(w.highway),opacity:.75});
              }
            }
          }, 2500+i*150);
        }
      });
    });
  }

  resetClosures(){
    // reopen all
    Array.from(this.closedWays).forEach(wid=>this.reopenWay(wid));
    this.closedWays.clear();
    this.graph=this.originalGraph.copy();
    this.setView(this.viewMode);
    this.status('‚úÖ All closures reset.');
  }

  clearAll(){
    if(this.drawn) this.drawn.clearLayers();
    Object.values(this.layers).forEach(l=>this.map.removeLayer(l)); this.layers={};
    this.resetState(false);
    this.status('Cleared. Draw a polygon to start.'); Q('#btnLoad').disabled=false;
  }

  resetState(disableButtons){
    this.nodesById={}; this.ways={}; this.edgesByWay={}; this.closedWays.clear();
    this.trafficByWay={}; this.importanceByWay={};
    this.graph.clear(); this.originalGraph=null; this.viewMode='roadtype'; Q('#selView').value='roadtype';
    ['#selPeriod','#btnImportance','#selView','#btnReset','#btnCloseMode'].forEach(s=>Q(s).disabled=disableButtons);
    Q('#stats').style.display='none';
  }
}

function Q(s){ return document.querySelector(s); }
function S(id,color,label){ Q(id).style.background=color; Q(id).parentElement.lastChild.nodeValue=' '+label; }
function esc(s){ return String(s??'').replace(/[&<>"']/g,c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c])); }

const app=new TrafficAnalyzer(); app.init();
</script>
</body>
</html>
