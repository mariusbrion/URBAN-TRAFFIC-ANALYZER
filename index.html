<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Urban Traffic Analyzer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            overflow: hidden;
        }
        
        #map {
            height: 100vh;
            width: 100%;
        }
        
        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 300px;
        }
        
        .control-panel h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        
        .instructions {
            padding: 10px;
            background: #E3F2FD;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 13px;
            color: #1976D2;
        }
        
        .btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        .btn:hover {
            background: #45a049;
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .btn-clear {
            background: #f44336;
        }
        
        .btn-clear:hover {
            background: #da190b;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
            font-size: 12px;
            color: #666;
        }
        
        .legend {
            margin-top: 15px;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-color {
            width: 30px;
            height: 3px;
            margin-right: 10px;
        }
        
        .loading {
            text-align: center;
            color: #4CAF50;
            font-weight: bold;
        }
        
        .street-popup {
            font-size: 13px;
        }
        
        .street-popup strong {
            color: #333;
        }
        
        .stats {
            margin-top: 10px;
            padding: 10px;
            background: #E8F5E9;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .stats div {
            margin: 3px 0;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="control-panel">
        <h3>üö¶ Traffic Analyzer</h3>
        
        <div class="instructions">
            üìç Draw a polygon on the map to select an area, then click "Load Streets"
        </div>
        
        <button id="loadStreetsBtn" class="btn" disabled>Load Street Network</button>
        <button id="clearBtn" class="btn btn-clear">Clear All</button>
        
        <div id="status" class="status">Draw a polygon to get started</div>
        
        <div id="stats" class="stats" style="display: none;">
            <strong>Network Stats:</strong>
            <div id="nodeCount">Nodes: 0</div>
            <div id="edgeCount">Streets: 0</div>
        </div>
        
        <div class="legend">
            <strong>Road Types:</strong>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF4444;"></div>
                <span>Motorway</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF8800;"></div>
                <span>Primary</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFB700;"></div>
                <span>Secondary</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4CAF50;"></div>
                <span>Residential</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #888888;"></div>
                <span>Other</span>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <script src="https://unpkg.com/graphology/dist/graphology.umd.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    
    <script>
        class TrafficAnalyzer {
            constructor() {
                this.map = null;
                this.graph = new graphology.Graph();
                this.streetLayers = {};
                this.osmData = null;
                this.drawnItems = null;
                this.selectedPolygon = null;
                
                // Default city: Bordeaux, France
                this.defaultCenter = [44.8378, -0.5792];
                this.defaultZoom = 14;
            }
            
            async initialize() {
                this.setupMap();
                this.setupDrawControls();
                this.setupEventHandlers();
                this.updateStatus('Draw a polygon on the map to select an area');
            }
            
            setupMap() {
                // Initialize Leaflet map
                this.map = L.map('map').setView(this.defaultCenter, this.defaultZoom);
                
                // Add OpenStreetMap base layer
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(this.map);
                
                console.log('Map initialized');
            }
            
            setupDrawControls() {
                // Layer for drawn items
                this.drawnItems = new L.FeatureGroup();
                this.map.addLayer(this.drawnItems);
                
                // Draw control
                const drawControl = new L.Control.Draw({
                    draw: {
                        polygon: {
                            shapeOptions: {
                                color: '#2196F3',
                                fillOpacity: 0.2
                            }
                        },
                        polyline: false,
                        rectangle: {
                            shapeOptions: {
                                color: '#2196F3',
                                fillOpacity: 0.2
                            }
                        },
                        circle: false,
                        marker: false,
                        circlemarker: false
                    },
                    edit: {
                        featureGroup: this.drawnItems,
                        remove: true
                    }
                });
                this.map.addControl(drawControl);
                
                // Event handlers for drawing
                this.map.on(L.Draw.Event.CREATED, (e) => {
                    const layer = e.layer;
                    this.drawnItems.addLayer(layer);
                    this.selectedPolygon = layer;
                    
                    document.getElementById('loadStreetsBtn').disabled = false;
                    this.updateStatus('Polygon drawn! Click "Load Street Network" to fetch data');
                });
                
                this.map.on(L.Draw.Event.DELETED, (e) => {
                    this.selectedPolygon = null;
                    document.getElementById('loadStreetsBtn').disabled = true;
                    this.updateStatus('Draw a polygon to select an area');
                });
            }
            
            setupEventHandlers() {
                document.getElementById('loadStreetsBtn').addEventListener('click', () => {
                    this.loadOSMData();
                });
                
                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.clearAll();
                });
            }
            
            clearAll() {
                // Clear drawn items
                this.drawnItems.clearLayers();
                this.selectedPolygon = null;
                
                // Clear streets
                Object.values(this.streetLayers).forEach(layer => {
                    this.map.removeLayer(layer);
                });
                this.streetLayers = {};
                
                // Clear graph
                this.graph.clear();
                
                // Reset UI
                document.getElementById('loadStreetsBtn').disabled = true;
                document.getElementById('stats').style.display = 'none';
                this.updateStatus('Draw a polygon to select an area');
            }
            
            async loadOSMData() {
                if (!this.selectedPolygon) {
                    alert('Please draw a polygon first');
                    return;
                }
                
                const btn = document.getElementById('loadStreetsBtn');
                btn.disabled = true;
                this.updateStatus('Loading street network...', true);
                
                try {
                    // Get polygon coordinates
                    const latlngs = this.selectedPolygon.getLatLngs()[0];
                    const polyCoords = latlngs.map(ll => `${ll.lat} ${ll.lng}`).join(' ');
                    
                    // Overpass API query for streets within polygon
                    const query = `
                        [out:json][timeout:60];
                        (
                          way["highway"]["highway"!~"footway|path|cycleway|steps|pedestrian|service"](poly:"${polyCoords}");
                        );
                        out body;
                        >;
                        out skel qt;
                    `;
                    
                    console.log('Sending Overpass query...');
                    
                    const response = await axios.post(
                        'https://overpass-api.de/api/interpreter',
                        query,
                        { headers: { 'Content-Type': 'text/plain' } }
                    );
                    
                    this.osmData = response.data;
                    console.log('OSM data loaded:', this.osmData.elements.length, 'elements');
                    
                    if (this.osmData.elements.length === 0) {
                        this.updateStatus('No streets found in this area. Try a larger area.');
                        btn.disabled = false;
                        return;
                    }
                    
                    // Parse and visualize
                    this.parseOSMIntoGraph();
                    this.visualizeStreets();
                    
                    // Update stats
                    document.getElementById('stats').style.display = 'block';
                    document.getElementById('nodeCount').textContent = `Nodes: ${this.graph.order}`;
                    document.getElementById('edgeCount').textContent = `Streets: ${Object.keys(this.streetLayers).length}`;
                    
                    this.updateStatus(`‚úÖ Loaded ${Object.keys(this.streetLayers).length} street segments`);
                    btn.disabled = false;
                    
                } catch (error) {
                    console.error('Error loading OSM data:', error);
                    this.updateStatus('Error loading street data. Please try again.');
                    btn.disabled = false;
                }
            }
            
            parseOSMIntoGraph() {
                // Clear existing graph
                this.graph.clear();
                
                // First pass: collect all nodes
                const nodes = {};
                this.osmData.elements.forEach(element => {
                    if (element.type === 'node') {
                        nodes[element.id] = {
                            lat: element.lat,
                            lon: element.lon
                        };
                    }
                });
                
                console.log('Collected', Object.keys(nodes).length, 'nodes');
                
                // Second pass: process ways (streets)
                let edgeCount = 0;
                this.osmData.elements.forEach(element => {
                    if (element.type === 'way' && element.tags && element.tags.highway) {
                        const wayId = element.id;
                        const nodeIds = element.nodes;
                        
                        // Add nodes to graph if not already present
                        nodeIds.forEach(nodeId => {
                            if (!this.graph.hasNode(nodeId) && nodes[nodeId]) {
                                this.graph.addNode(nodeId, {
                                    lat: nodes[nodeId].lat,
                                    lon: nodes[nodeId].lon
                                });
                            }
                        });
                        
                        // Add edges between consecutive nodes
                        for (let i = 0; i < nodeIds.length - 1; i++) {
                            const source = nodeIds[i];
                            const target = nodeIds[i + 1];
                            
                            if (nodes[source] && nodes[target]) {
                                const edgeId = `${wayId}_${i}`;
                                
                                try {
                                    // Correct order: source, target, attributes
                                    this.graph.addEdge(source, target, {
                                        edgeId: edgeId,
                                        wayId: wayId,
                                        highway: element.tags.highway,
                                        name: element.tags.name || 'Unnamed',
                                        maxspeed: element.tags.maxspeed || 'Unknown',
                                        coordinates: [
                                            [nodes[source].lat, nodes[source].lon],
                                            [nodes[target].lat, nodes[target].lon]
                                        ]
                                    });
                                    edgeCount++;
                                } catch (e) {
                                    // Edge might already exist, skip
                                }
                            }
                        }
                    }
                });
                
                console.log('Graph built:', this.graph.order, 'nodes,', edgeCount, 'edges');
            }
            
            visualizeStreets() {
                // Clear existing street layers
                Object.values(this.streetLayers).forEach(layer => {
                    this.map.removeLayer(layer);
                });
                this.streetLayers = {};
                
                // Draw each edge
                let layerCount = 0;
                this.graph.forEachEdge((edge, attributes) => {
                    const coords = attributes.coordinates;
                    const color = this.getRoadColor(attributes.highway);
                    const weight = this.getRoadWeight(attributes.highway);
                    
                    const polyline = L.polyline(coords, {
                        color: color,
                        weight: weight,
                        opacity: 0.7
                    }).addTo(this.map);
                    
                    // Add popup with street info
                    const popupContent = `
                        <div class="street-popup">
                            <strong>${attributes.name}</strong><br>
                            Type: ${attributes.highway}<br>
                            Max Speed: ${attributes.maxspeed}<br>
                            Way ID: ${attributes.wayId}
                        </div>
                    `;
                    polyline.bindPopup(popupContent);
                    
                    this.streetLayers[attributes.edgeId] = polyline;
                    layerCount++;
                });
                
                console.log('Visualized', layerCount, 'street segments');
            }
            
            getRoadColor(highway) {
                const colors = {
                    'motorway': '#FF4444',
                    'motorway_link': '#FF4444',
                    'trunk': '#FF6644',
                    'trunk_link': '#FF6644',
                    'primary': '#FF8800',
                    'primary_link': '#FF8800',
                    'secondary': '#FFB700',
                    'secondary_link': '#FFB700',
                    'tertiary': '#FFDD00',
                    'residential': '#4CAF50',
                    'unclassified': '#999999',
                    'living_street': '#4CAF50'
                };
                
                return colors[highway] || '#888888';
            }
            
            getRoadWeight(highway) {
                const weights = {
                    'motorway': 4,
                    'motorway_link': 3,
                    'trunk': 4,
                    'trunk_link': 3,
                    'primary': 3,
                    'primary_link': 2,
                    'secondary': 2,
                    'secondary_link': 2,
                    'tertiary': 2,
                    'residential': 1.5,
                    'unclassified': 1.5
                };
                
                return weights[highway] || 1.5;
            }
            
            updateStatus(message, loading = false) {
                const statusDiv = document.getElementById('status');
                statusDiv.innerHTML = loading ? `<div class="loading">${message}</div>` : message;
            }
        }
        
        // Initialize the application
        const analyzer = new TrafficAnalyzer();
        analyzer.initialize();
    </script>
</body>
</html>
